{"version":3,"sources":["webpack://notation/webpack/universalModuleDefinition","webpack://notation/webpack/bootstrap","webpack://notation/./src/core/notation.error.js","webpack://notation/./src/utils.js","webpack://notation/./src/core/notation.glob.js","webpack://notation/./src/core/notation.js","webpack://notation/./src/index.js"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","setProto","setPrototypeOf","NotationError","_this","message","arguments","length","undefined","_classCallCheck","_getPrototypeOf","_assertThisInitialized","writable","Error","captureStackTrace","stack","oPROTO","VAR","ARRAY_NOTE","OBJECT_BRACKETS","ESCAPE","NON_NEG_WILDCARD_TRAIL","utils","re","ARRAY_GLOB_NOTE","WILDCARD","WILDCARDS","NEGATE_ALL","isObject","toString","isArray","isCollection","isset","ensureArray","hasOwn","collection","keyOrIndex","deepCopy","copy","keys","forEach","k","map","each","array","callback","thisArg","len","index","apply","eachRight","eachProp","eachItem","pregQuote","str","String","replace","stringOrArrayOf","hasSingleItemOf","arr","itemValue","normalizeGlobStr","glob","trim","normalizeNote","note","test","match","parseInt","concat","joinNotes","notes","lastIndex","current","next","join","getNewNotation","newNotation","notation","newN","errMsg","reMATCHER","reVALIDATOR","RegExp","ERR_INVALID","NotationGlob","notation_glob_classCallCheck","ins","_inspect","split","absGlob","last","parent","slice","_","_objectSpread","regexp","toRegExp","isValid","g","indexOf","globA","globB","a","b","notesA","notesB","isNegated","covers","_coversNote","bang","restrictive","Math","max","notesI","push","normalize","wildCountA","wildCountB","globList","sort","compare","_covers","_intersect","original","list","_negFirstSort","_negLastSort","negateAll","normalized","ignored","intersections","checkAddIntersection","gA","gB","inter","hasInverted","indexA","duplicate","hasExactNeg","negCoversPos","negCoveredByPos","negCoveredByNeg","posCoversPos","posCoveredByNeg","posCoveredByPos","indexB","splice","coversB","coveredByB","keepNeg","keepPos","globsListA","globsListB","union","notCovered","hasExact","negCoversNeg","posCoversNeg","keep","globsA","globsB","_compareUnion","listA","listB","Notation","bIsArr","_rx","ERR","DEFAULT_OPTS","freeze","strict","preserveIndices","source","options","notation_classCallCheck","src","_source","_isArray","countNotes","levelNotes","eachNote","_each","parentNotation","topSource","byLevel","currentNotation","level","levelNotation","merge","expand","result","has","lastNoteNormalized","lastNote","parentIsArray","inspect","defaultValue","msg","overwrite","currentIsLast","nCurrentNote","nNextNote","nextIsArrayNote","notationsObject","_this2","set","notations","_this3","inspectRemove","globNotations","_this4","globs","empty","filtered","endStar","firstIsWildcard","shift","globNotation","remove","copyFrom","originalNotation","destination","target","moveTo","rename","copyTo","extract","extrude","_options","notation_objectSpread","Glob","__webpack_exports__","notation_Notation"],"mappings":"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","file":"notation.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"notation\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"notation\"] = factory();\n\telse\n\t\troot[\"notation\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"lib/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/* eslint consistent-this:0, no-prototype-builtins:0 */\n\nconst setProto = Object.setPrototypeOf;\n\n/**\n *  Error class specific to `Notation`.\n *  @name Notation.Error\n *  @memberof! Notation\n *  @class\n *\n */\nclass NotationError extends Error {\n\n    /**\n     *  Initializes a new `Notation.Error` instance.\n     *  @constructs Notation.Error\n     *  @param {String} message - The error message.\n     */\n    constructor(message = '') {\n        super(message);\n        setProto(this, NotationError.prototype);\n\n        Object.defineProperty(this, 'name', {\n            enumerable: false,\n            writable: false,\n            value: 'NotationError'\n        });\n\n        Object.defineProperty(this, 'message', {\n            enumerable: false,\n            writable: true,\n            value: message\n        });\n\n        /* istanbul ignore else */\n        if (Error.hasOwnProperty('captureStackTrace')) { // V8\n            Error.captureStackTrace(this, NotationError);\n        } else {\n            Object.defineProperty(this, 'stack', {\n                enumerable: false,\n                writable: false,\n                value: (new Error(message)).stack\n            });\n        }\n    }\n\n}\n\nexport { NotationError };\n","\nimport { NotationError } from './core/notation.error';\n\nconst oPROTO = Object.prototype;\n\nconst VAR = /^[a-z$_][a-z$_\\d]*$/i;\nconst ARRAY_NOTE = /^\\[(\\d+)\\]$/;\nconst ARRAY_GLOB_NOTE = /^\\[(\\d+|\\*)\\]$/;\nconst OBJECT_BRACKETS = /^\\[(?:'(.*)'|\"(.*)\"|`(.*)`)\\]$/;\nconst ESCAPE = /[.\\\\+*?[^\\]$(){}=!<>|:-]/g;\nconst WILDCARD = /^(\\[\\*\\]|\\*)$/;\n// matches `*` and `[*]` if outside of quotes.\nconst WILDCARDS = /(\\*|\\[\\*\\])(?=(?:[^\"]|\"[^\"]*\")*$)(?=(?:[^']|'[^']*')*$)/g;\n// matches trailing wildcards at the end of a non-negated glob.\n// e.g. `x.y.*[*].*` » $1 = `x.y`, $2 = `.*[*].*`\nconst NON_NEG_WILDCARD_TRAIL = /^(?!!)(.+?)(\\.\\*|\\[\\*\\])+$/;\nconst NEGATE_ALL = /^!(\\*|\\[\\*\\])$/;\n\nconst utils = {\n\n    re: {\n        VAR,\n        ARRAY_NOTE,\n        ARRAY_GLOB_NOTE,\n        OBJECT_BRACKETS,\n        ESCAPE,\n        WILDCARD,\n        WILDCARDS,\n        NON_NEG_WILDCARD_TRAIL,\n        NEGATE_ALL\n    },\n\n    isObject(o) {\n        return oPROTO.toString.call(o) === '[object Object]';\n    },\n\n    isArray(o) {\n        return oPROTO.toString.call(o) === '[object Array]';\n    },\n\n    isCollection(o) {\n        return utils.isObject(o) || utils.isArray(o);\n    },\n\n    isset(o) {\n        return o !== undefined && o !== null;\n    },\n\n    ensureArray(o) {\n        if (utils.isArray(o)) return o;\n        return o === null || o === undefined ? [] : [o];\n    },\n\n    hasOwn(collection, keyOrIndex) {\n        if (!collection) return false;\n        const isArr = utils.isArray(collection);\n        if (!isArr && typeof keyOrIndex === 'string') {\n            return keyOrIndex && oPROTO.hasOwnProperty.call(collection, keyOrIndex);\n        }\n        if (typeof keyOrIndex === 'number') {\n            return keyOrIndex >= 0 && keyOrIndex < collection.length;\n        }\n        return false;\n    },\n\n    deepCopy(collection) {\n        if (utils.isObject(collection)) {\n            const copy = {};\n            Object.keys(collection).forEach(k => {\n                copy[k] = utils.deepCopy(collection[k]);\n            });\n            return copy;\n        }\n        if (utils.isArray(collection)) return collection.map(utils.deepCopy);\n        // not object or array\n        return collection;\n    },\n\n    // iterates over elements of an array, executing the callback for each\n    // element.\n    each(array, callback, thisArg) {\n        const len = array.length;\n        let index = -1;\n        while (++index < len) {\n            if (callback.apply(thisArg, [array[index], index, array]) === false) break;\n        }\n    },\n\n    eachRight(array, callback, thisArg) {\n        let index = array.length;\n        while (index--) {\n            if (callback.apply(thisArg, [array[index], index, array]) === false) break;\n        }\n    },\n\n    eachProp(object, callback, thisArg) {\n        const keys = Object.keys(object);\n        let index = -1;\n        while (++index < keys.length) {\n            const key = keys[index];\n            if (callback.apply(thisArg, [object[key], key, object]) === false) break;\n        }\n    },\n\n    eachItem(collection, callback, thisArg) {\n        if (utils.isArray(collection)) {\n            return utils.each(collection, callback, thisArg);\n        }\n        return utils.eachProp(collection, callback, thisArg);\n    },\n\n    pregQuote(str) {\n        return String(str).replace(ESCAPE, '\\\\$&');\n    },\n\n    stringOrArrayOf(o, value) {\n        return typeof value === 'string'\n            && (o === value\n                || (utils.isArray(o) && o.length === 1 && o[0] === value)\n            );\n    },\n\n    hasSingleItemOf(arr, itemValue) {\n        return arr.length === 1\n            && (arguments.length === 2 ? arr[0] === itemValue : true);\n    },\n\n    // remove trailing/redundant wildcards if not negated\n    normalizeGlobStr(glob) {\n        return glob.trim().replace(NON_NEG_WILDCARD_TRAIL, '$1');\n    },\n\n    normalizeNote(note) {\n        if (VAR.test(note)) return note;\n        // check array index notation e.g. `[1]`\n        let m = note.match(ARRAY_NOTE);\n        if (m) return parseInt(m[1], 10);\n        // check object bracket notation e.g. `[\"a-b\"]`\n        m = note.match(OBJECT_BRACKETS);\n        if (m) return m[1] || m[2] || m[3];\n        throw new NotationError(`Invalid note: \"${note}\"`);\n    },\n\n    joinNotes(notes) {\n        const lastIndex = notes.length - 1;\n        return notes.map((current, i) => {\n            if (!current) return '';\n            const next = lastIndex >= i + 1 ? notes[i + 1] : null;\n            const dot = next\n                ? next[0] === '[' ? '' : '.'\n                : '';\n            return current + dot;\n        }).join('');\n    },\n\n    getNewNotation(newNotation, notation) {\n        const errMsg = `Invalid new notation: '${newNotation}'`;\n        // note validations (for newNotation and notation) are already made by\n        // other methods in the flow.\n        let newN;\n        if (typeof newNotation === 'string') {\n            newN = newNotation.trim();\n            if (!newN) throw new NotationError(errMsg);\n            return newN;\n        }\n        if (notation && !utils.isset(newNotation)) return notation;\n        throw new NotationError(errMsg);\n    }\n\n};\n\nexport { utils };\n","/* eslint no-use-before-define:0, consistent-return:0, max-statements:0 */\n\nimport { Notation } from './notation';\nimport { NotationError } from './notation.error';\nimport { utils } from '../utils';\n\n// http://www.linfo.org/wildcard.html\n// http://en.wikipedia.org/wiki/Glob_%28programming%29\n// http://en.wikipedia.org/wiki/Wildcard_character#Computing\n\n// created test @ https://regex101.com/r/U08luj/2\nconst reMATCHER = /(\\[(\\d+|\\*|\".*\"|'.*')\\]|[a-z$_][a-z$_\\d]*|\\*)/gi; // ! negation should be removed first\n// created test @ https://regex101.com/r/mC8unE/3\n// /^!?(\\*|[a-z$_][a-z$_\\d]*|\\[(\\d+|\".*\"|'.*'|`.*`|\\*)\\])(\\[(\\d+|\".*\"|'.*'|`.*`|\\*)\\]|\\.[a-z$_][a-z$_\\d]*|\\.\\*)*$/i\nconst reVALIDATOR = new RegExp(\n    '^'\n    + '!?('                             // optional negation, only in the front\n    + '\\\\*'                             // wildcard star\n    + '|'                               // OR\n    + '[a-z$_][a-z$_\\\\d]*'              // JS variable syntax\n    + '|'                               // OR\n    + '\\\\[(\\\\d+|\\\\*|\".*\"|\\'.*\\')\\\\]'    // array index or wildcard, or object bracket notation\n    + ')'                               // exactly once\n    + '('\n    + '\\\\[(\\\\d+|\\\\*|\".*\"|\\'.*\\')\\\\]'    // followed by same\n    + '|'                               // OR\n    + '\\\\.[a-z$_][a-z$_\\\\d]*'           // dot, then JS variable syntax\n    + '|'                               // OR\n    + '\\\\.\\\\*'                          // dot, then wildcard star\n    + ')*'                              // (both) may repeat any number of times\n    + '$'\n    , 'i'\n);\n\nconst { re } = utils;\nconst ERR_INVALID = 'Invalid glob notation: ';\n\n/**\n *  `Notation.Glob` is a utility for validating, comparing and sorting\n *  dot-notation globs.\n *\n *  You can use {@link http://www.linfo.org/wildcard.html|wildcard} stars `*`\n *  and negate the notation by prepending a bang `!`. A star will include all\n *  the properties at that level and a negated notation will be excluded.\n *  @name Notation.Glob\n *  @memberof! Notation\n *  @class\n *\n *  @example\n *  // for the following object;\n *  { name: 'John', billing: { account: { id: 1, active: true } } };\n *\n *  'billing.account.*'  // represents value `{ id: 1, active: true }`\n *  'billing.account.id' // represents value `1`\n *  '!billing.account.*' // represents value `{ name: 'John' }`\n *  'name' // represents `'John'`\n *  '*' // represents the whole object\n *\n *  @example\n *  var glob = new Notation.Glob('billing.account.*');\n *  glob.test('billing.account.id'); // true\n */\nclass NotationGlob {\n\n    /**\n     *  Constructs a `Notation.Glob` object with the given glob string.\n     *  @constructs Notation.Glob\n     *  @param {String} glob - Notation string with globs.\n     *\n     *  @throws {NotationError} - If given notation glob is invalid.\n     */\n    constructor(glob) {\n        const ins = NotationGlob._inspect(glob);\n        const notes = NotationGlob.split(ins.absGlob, true);\n        const last = notes[notes.length - 1];\n        const parent = notes.length > 1\n            ? ins.absGlob.slice(0, -last.length).replace(/\\.$/, '')\n            : null;\n        this._ = {\n            ...ins,\n            regexp: NotationGlob.toRegExp(ins.absGlob),\n            notes,\n            last,\n            parent\n        };\n    }\n\n    // --------------------------------\n    // INSTANCE PROPERTIES\n    // --------------------------------\n\n    /**\n     *  Gets the normalized glob notation string.\n     *  @name Notation.Glob#glob\n     *  @type {String}\n     */\n    get glob() {\n        return this._.glob;\n    }\n\n    /**\n     *  Gets the absolute glob notation without the negation prefix `!` and\n     *  redundant trailing wildcards.\n     *  @name Notation.Glob#absGlob\n     *  @type {String}\n     */\n    get absGlob() {\n        return this._.absGlob;\n    }\n\n    /**\n     *  Specifies whether this glob is negated with a `!` prefix.\n     *  @name Notation.Glob#isNegated\n     *  @type {Boolean}\n     */\n    get isNegated() {\n        return this._.isNegated;\n    }\n\n    /**\n     *  Represents this glob in regular expressions.\n     *  Note that the negation prefix (`!`) is ignored, if any.\n     *  @name Notation.Glob#regexp\n     *  @type {RegExp}\n     */\n    get regexp() {\n        return this._.regexp;\n    }\n\n    /**\n     *  List of notes/levels of this glob notation. Note that trailing,\n     *  redundant wildcards are removed from the original glob notation.\n     *  @name Notation.Glob#notes\n     *  @alias Notation.Glob#levels\n     *  @type {Array}\n     */\n    get notes() {\n        return this._.notes;\n    }\n\n    /**\n     *  Alias of `Notation.Glob#notes`.\n     *  @private\n     *  @name Notation.Glob#notes\n     *  @alias Notation.Glob#levels\n     *  @type {Array}\n     */\n    get levels() {\n        return this._.notes;\n    }\n\n    /**\n     *  Gets the first note of this glob notation.\n     *  @name Notation.Glob#first\n     *  @type {String}\n     */\n    get first() {\n        return this.notes[0];\n    }\n\n    /**\n     *  Gets the last note of this glob notation.\n     *  @name Notation.Glob#last\n     *  @type {String}\n     */\n    get last() {\n        return this._.last;\n    }\n\n    /**\n     *  Gets the parent notation (up to but excluding the last note) from the\n     *  glob notation string. Note that initially, trailing/redundant wildcards\n     *  are removed.\n     *  @name Notation.Glob#parent\n     *  @type {String}\n     *\n     *  @example\n     *  NotationGlob.create('first.second.*').parent; // \"first.second\"\n     *  NotationGlob.create('*.x.*').parent; // \"*\"\n     *  NotationGlob.create('*').parent; // null (no parent)\n     */\n    get parent() {\n        return this._.parent;\n    }\n\n    // --------------------------------\n    // INSTANCE METHODS\n    // --------------------------------\n\n    /**\n     *  Checks whether the given notation value matches the source notation\n     *  glob.\n     *  @name Notation.Glob#test\n     *  @function\n     *  @param {String} notation - The notation string to be tested. Cannot have\n     *  any globs.\n     *  @returns {Boolean} -\n     *  @throws {NotationError} - If given `notation` is not valid or contains\n     *  any globs.\n     *\n     *  @example\n     *  const glob = new Notation.Glob('!prop.*.name');\n     *  glob.test(\"prop.account.name\"); // true\n     */\n    test(notation) {\n        if (!Notation.isValid(notation)) {\n            throw new NotationError(`Invalid notation: '${notation}'`);\n        }\n        // return this.regexp.test(notation);\n        return NotationGlob._covers(this, notation);\n    }\n\n    /**\n     *  Specifies whether this glob notation can represent (or cover) the given\n     *  glob notation. Note that negation prefix is ignored, if any.\n     *  @param {String|Array|NotationGlob} glob  Glob notation string, glob\n     *  notes array or a `NotationGlob` instance.\n     *  @returns {Boolean} -\n     *\n     *  @example\n     *  const glob = Notation.Glob.create;\n     *  glob('*.y').covers('x.y')      // true\n     *  glob('x[*].y').covers('x[*]')  // false\n     */\n    covers(glob) {\n        return NotationGlob._covers(this, glob);\n    }\n\n    /**\n     *  Gets the intersection of this and the given glob notations. When\n     *  restrictive, if any one of them is negated, the outcome is negated.\n     *  Otherwise, only if both of them are negated, the outcome is negated.\n     *  @param {String} glob - Second glob to be used.\n     *  @param {Boolean} [restrictive=false] - Whether the intersection should\n     *  be negated when one of the globs is negated.\n     *  @returns {String} - Intersection notation if any; otherwise `null`.\n     *  @example\n     *  const glob = Notation.Glob.create;\n     *  glob('x.*').intersect('!*.y')         // 'x.y'\n     *  glob('x.*').intersect('!*.y', true)   // '!x.y'\n     */\n    intersect(glob, restrictive = false) {\n        return NotationGlob._intersect(this.glob, glob, restrictive);\n    }\n\n    // --------------------------------\n    // STATIC MEMBERS\n    // --------------------------------\n\n    /**\n     *  Basically constructs a new `NotationGlob` instance\n     *  with the given glob string.\n     *  @name Notation.Glob.create\n     *  @function\n     *  @param {String} glob - The source notation glob.\n     *  @returns {NotationGlob} -\n     *\n     *  @example\n     *  const glob = Notation.Glob.create(strGlob);\n     *  // equivalent to:\n     *  const glob = new Notation.Glob(strGlob);\n     */\n    static create(glob) {\n        return new NotationGlob(glob);\n    }\n\n    // Created test at: https://regex101.com/r/tJ7yI9/4\n    /**\n     *  Validates the given notation glob.\n     *  @name Notation.Glob.isValid\n     *  @function\n     *\n     *  @param {String} glob - Notation glob to be validated.\n     *  @returns {Boolean} -\n     */\n    static isValid(glob) {\n        return typeof glob === 'string' && reVALIDATOR.test(glob);\n    }\n\n    /**\n     *  Specifies whether the given glob notation includes any valid wildcards\n     *  or negation bang prefix.\n     *  @param {String} glob - Glob notation to be checked.\n     *  @returns {Boolean} -\n     */\n    static hasMagic(glob) {\n        // // eslint-disable-next-line no-console\n        // console.log('---', typeof glob, glob);\n        // // eslint-disable-next-line no-console\n        // console.log('NotationGlob.isValid', NotationGlob.isValid(glob));\n        // // eslint-disable-next-line no-console\n        // console.log('re.WILDCARDS.test', re.WILDCARDS.test(glob));\n        // // eslint-disable-next-line no-console\n        // console.log('glob[0] === !', glob[0] === '!');\n        // eslint-disable-next-line no-console\n        // console.log('all', NotationGlob.isValid(glob) && (re.WILDCARDS.test(glob) === true || glob[0] === '!'));\n        return NotationGlob.isValid(glob) && (re.WILDCARDS.test(glob) || glob[0] === '!');\n    }\n\n    /**\n     *  Gets a regular expressions instance from the given glob notation.\n     *  Note that the bang `!` prefix will be ignored if the given glob is negated.\n     *  @name Notation.Glob.toRegExp\n     *  @function\n     *  @param {String} glob - Glob notation to be converted.\n     *\n     *  @returns {RegExp} - A `RegExp` instance from the glob.\n     *\n     *  @throws {NotationError} - If given notation glob is invalid.\n     */\n    static toRegExp(glob) {\n        if (!NotationGlob.isValid(glob)) {\n            throw new NotationError(`${ERR_INVALID} '${glob}'`);\n        }\n\n        let g = glob.indexOf('!') === 0 ? glob.slice(1) : glob;\n        g = utils.pregQuote(g)\n            // `[*]` always represents array index e.g. `[1]`. so we'd replace\n            // `\\[\\*\\]` with `\\[\\d+\\]` but we should also watch for quotes: e.g.\n            // `[\"x[*]y\"]`\n            .replace(/\\\\\\[\\\\\\*\\\\\\](?=(?:[^\"]|\"[^\"]*\")*$)(?=(?:[^']|'[^']*')*$)/g, '\\\\[\\\\d+\\\\]')\n            // `*` within quotes (e.g. ['*']) is non-wildcard, just a regular star char.\n            // `*` outside of quotes is always JS variable syntax e.g. `prop.*`\n            .replace(/\\\\\\*(?=(?:[^\"]|\"[^\"]*\")*$)(?=(?:[^']|'[^']*')*$)/g, '[a-z$_][a-z$_\\\\d]*')\n            .replace(/\\\\\\?/g, '.');\n        return new RegExp('^' + g + '(?:[\\\\[\\\\.].+|$)', 'i');\n        // it should either end ($) or continue with a dot or bracket. So for\n        // example, `company.*` will produce `/^company\\.[a-z$_][a-z$_\\\\d]*(?:[\\\\[|\\\\.].+|$)/`\n        // which will match both `company.name` and `company.address.street` but\n        // will not match `some.company.name`. Also `!password` will not match\n        // `!password_reset`.\n    }\n\n    /**\n     *  Specifies whether first glob notation can represent (or cover) the\n     *  second.\n     *  @private\n     *  @param {String|Object|NotationGlob} globA  Source glob notation string or inspection\n     *  result object or `NotationGlob` instance.\n     *  @param {String|Object|NotationGlob} globB  Glob notation string or inspection result\n     *  object or `NotationGlob` instance.\n     *  @returns {Boolean} -\n     *\n     *  @example\n     *  const { covers } = NotationGlob;\n     *  covers('*.y', 'x.y')      // true\n     *  covers('x[*].y', 'x[*]')  // false\n     */\n    static _covers(globA, globB) {\n        const a = typeof globA === 'string'\n            ? new NotationGlob(globA)\n            : globA; // assume (globA instanceof NotationGlob || utils.type(globA) === 'object')\n\n        const b = typeof globB === 'string'\n            ? new NotationGlob(globB)\n            : globB;\n\n        const notesA = a.notes || NotationGlob.split(a.absGlob);\n        const notesB = b.notes || NotationGlob.split(b.absGlob);\n\n        // !x.*.* does not cover !x.* or x.* bec. !x.*.* !== x.* !== x\n        // x.*.* covers x.* bec. x.*.* === x.* === x\n        if (a.isNegated && notesA.length > notesB.length) return false;\n\n        let covers = true;\n        for (let i = 0; i < notesA.length; i++) {\n            if (!_coversNote(notesA[i], notesB[i])) {\n                covers = false;\n                break;\n            }\n        }\n        return covers;\n    }\n\n    /**\n     *  Gets the intersection notation of two glob notations. When restrictive,\n     *  if any one of them is negated, the outcome is negated. Otherwise, only\n     *  if both of them are negated, the outcome is negated.\n     *  @private\n     *  @param {String} globA - First glob to be used.\n     *  @param {String} globB - Second glob to be used.\n     *  @param {Boolean} [restrictive=false] - Whether the intersection should\n     *  be negated when one of the globs is negated.\n     *  @returns {String} - Intersection notation if any; otherwise `null`.\n     *  @example\n     *  _intersect('!*.y', 'x.*', false)     // 'x.y'\n     *  _intersect('!*.y', 'x.*', true)      // '!x.y'\n     */\n    static _intersect(globA, globB, restrictive = false) {\n        // const bang = restrictive\n        //     ? (globA[0] === '!' || globB[0] === '!' ? '!' : '')\n        //     : (globA[0] === '!' && globB[0] === '!' ? '!' : '');\n\n        const notesA = NotationGlob.split(globA, true);\n        const notesB = NotationGlob.split(globB, true);\n\n        let bang;\n        if (restrictive) {\n            bang = globA[0] === '!' || globB[0] === '!' ? '!' : '';\n        } else {\n            if (globA[0] === '!' && globB[0] === '!') {\n                bang = '!';\n            } else {\n                bang = ((notesA.length > notesB.length && globA[0] === '!')\n                        || (notesB.length > notesA.length && globB[0] === '!'))\n                    ? '!'\n                    : '';\n            }\n        }\n\n        const len = Math.max(notesA.length, notesB.length);\n        let notesI = [];\n        let a, b;\n        //   x.*  ∩  *.y   »  x.y\n        // x.*.*  ∩  *.y   »  x.y.*\n        // x.*.z  ∩  *.y   »  x.y.z\n        //   x.y  ∩  *.b   »  (n/a)\n        //   x.y  ∩  a.*   »  (n/a)\n        for (let i = 0; i < len; i++) {\n            a = notesA[i];\n            b = notesB[i];\n            if (a === b) {\n                notesI.push(a);\n            } else if (a && re.WILDCARD.test(a)) {\n                if (!b) {\n                    notesI.push(a);\n                } else {\n                    notesI.push(b);\n                }\n            } else if (b && re.WILDCARD.test(b)) {\n                if (!a) {\n                    notesI.push(b);\n                } else {\n                    notesI.push(a);\n                }\n            } else if (a && !b) {\n                notesI.push(a);\n            } else if (!a && b) {\n                notesI.push(b);\n            } else { // if (a !== b) {\n                notesI = [];\n                break;\n            }\n        }\n\n        if (notesI.length > 0) return bang + utils.joinNotes(notesI);\n        return null;\n    }\n\n    /**\n     *  Undocumented.\n     *  @private\n     *  @param {String} glob -\n     *  @returns {Object} -\n     */\n    static _inspect(glob) {\n        const g = utils.normalizeGlobStr(glob);\n        if (!NotationGlob.isValid(g)) {\n            throw new NotationError(`${ERR_INVALID} '${glob}'`);\n        }\n        const isNegated = g[0] === '!';\n        return {\n            glob: g,\n            isNegated,\n            absGlob: isNegated ? g.slice(1) : g\n        };\n    }\n\n    /**\n     *  Splits the given glob notation string into its notes (levels). Note that\n     *  this will exclude the `!` negation prefix, if it exists.\n     *  @param {String} glob  Glob notation string to be splitted.\n     *  @param {String} [normalize=false]  Whether to remove trailing, redundant\n     *  wildcards.\n     *  @returns {Array} - A string array of glob notes (levels).\n     *  @throws {NotationError} - If given glob notation is invalid.\n     *  @example\n     *  Notation.Glob.split('*.list[2].value')  // ['*', 'list', '[2]', 'value']\n     *  // you can get the same result from the .notes property of a Notation.Glob instance.\n     */\n    static split(glob, normalize = false) {\n        if (!NotationGlob.isValid(glob)) {\n            throw new NotationError(`${ERR_INVALID} '${glob}'`);\n        }\n        const g = normalize ? utils.normalizeGlobStr(glob) : glob;\n        return g.replace(/^!/, '').match(reMATCHER);\n    }\n\n    /**\n     *  Compares two given notation globs and returns an integer value as a\n     *  result. This is generally used to sort glob arrays. Loose globs (with\n     *  stars especially closer to beginning of the glob string) and globs\n     *  representing the parent/root of the compared property glob come first.\n     *  Verbose/detailed/exact globs come last. (`* < *.abc < abc`).\n     *\n     *  For instance; `store.address` comes before `store.address.street`. So\n     *  this works both for `*, store.address.street, !store.address` and `*,\n     *  store.address, !store.address.street`. For cases such as `prop.id` vs\n     *  `!prop.id` which represent the same property; the negated glob comes\n     *  last.\n     *  @name Notation.Glob.compare\n     *  @function\n     *\n     *  @param {String} globA - First notation glob to be compared.\n     *  @param {String} globB - Second notation glob to be compared.\n     *\n     *  @returns {Number} - Returns `-1` if `globA` comes first, `1` if `globB`\n     *  comes first and `0` if equivalent priority.\n     *\n     *  @throws {NotationError} - If either `globA` or `globB` is invalid glob\n     *  notation.\n     *\n     *  @example\n     *  const { compare } = Notation.Glob;\n     *  compare('*', 'info.user')               // -1\n     *  compare('*', '[*]')                     // 0\n     *  compare('info.*.name', 'info.user')     // 1\n     */\n    static compare(globA, globB) {\n        // trivial case, both are exactly the same!\n        // or both are wildcard e.g. `*` or `[*]`\n        if (globA === globB || (re.WILDCARD.test(globA) && re.WILDCARD.test(globB))) return 0;\n\n        const { split, _inspect } = NotationGlob;\n\n        const a = _inspect(globA);\n        const b = _inspect(globB);\n        const notesA = split(a.absGlob);\n        const notesB = split(b.absGlob);\n\n        // Check depth (number of levels)\n        if (notesA.length === notesB.length) {\n            // count wildcards\n            const wildCountA = (a.absGlob.match(re.WILDCARDS) || []).length;\n            const wildCountB = (b.absGlob.match(re.WILDCARDS) || []).length;\n            if (wildCountA === wildCountB) {\n                // check for negation\n                if (!a.isNegated && b.isNegated) return -1;\n                if (a.isNegated && !b.isNegated) return 1;\n                // both are negated or neither are, return alphabetical\n                return a.absGlob < b.absGlob ? -1 : (a.absGlob > b.absGlob ? 1 : 0);\n            }\n            return wildCountA > wildCountB ? -1 : 1;\n        }\n\n        return notesA.length < notesB.length ? -1 : 1;\n    }\n\n    /**\n     *  Sorts the notation globs in the given array by their priorities. Loose\n     *  globs (with stars especially closer to beginning of the glob string);\n     *  globs representing the parent/root of the compared property glob come\n     *  first. Verbose/detailed/exact globs come last. (`* < *abc < abc`).\n     *\n     *  For instance; `store.address` comes before `store.address.street`. For\n     *  cases such as `prop.id` vs `!prop.id` which represent the same property;\n     *  the negated glob wins (comes last).\n     *  @name Notation.Glob.sort\n     *  @function\n     *  @param {Array} globList - The notation globs array to be sorted. The\n     *  passed array reference is modified.\n     *  @returns {Array} -\n     *\n     *  @example\n     *  const { sort } = Notation.Glob;\n     *  sort(['!prop.*.name', 'prop.*', 'prop.id'])\n     *  // ['prop.*', 'prop.id', '!prop.*.name'];\n     */\n    static sort(globList) {\n        return globList.sort(NotationGlob.compare);\n    }\n\n    /**\n     *  Normalizes the given notation globs array by removing duplicate or\n     *  redundant items, eliminating extra verbosity (also with intersection\n     *  globs) and returns a priority-sorted globs array.\n     *\n     *  <ul>\n     *  <li>If any exact duplicates found, all except first is removed.\n     *  <br />example: `['car', 'dog', 'car']` normalizes to `['car', 'dog']`.</li>\n     *  <li>If both normal and negated versions of a glob are found, negated wins.\n     *  <br />example: `['*', 'id', '!id']` normalizes to `['*', '!id']`.</li>\n     *  <li>If a glob is covered by another, it's removed.\n     *  <br />example: `['car.*', 'car.model']` normalizes to `['car']`.</li>\n     *  <li>If a negated glob is covered by another glob, it's kept.\n     *  <br />example: `['*', 'car', '!car.model']` normalizes as is.</li>\n     *  <li>If a negated glob is not covered by another or it does not cover any other;\n     *  then we check for for intersection glob. If found, adds them to list;\n     *  removes the original negated.\n     *  <br />example: `['car.*', '!*.model']` normalizes as to `['car', '!car.model']`.</li>\n     *  <li>In restrictive mode; if a glob is covered by another negated glob, it's removed.\n     *  Otherwise, it's kept.\n     *  <br />example: `['*', '!car.*', 'car.model']` normalizes to `['*', '!car']` if restrictive.</li>\n     *  </ul>\n     *  @name Notation.Glob.normalize\n     *  @function\n     *  @param {Array} globList - Notation globs array to be normalized.\n     *  @param {Boolean} [restrictive=false] - Whether negated items strictly\n     *  remove every match. Note that, regardless of this option, if any item has an\n     *  exact negated version; non-negated is always removed.\n     *  @returns {Array} -\n     *\n     *  @throws {NotationError} - If any item in globs list is invalid.\n     *\n     *  @example\n     *  const { normalize } = Notation.Glob;\n     *  const globs = ['*', '!id', 'name', '!car.model', 'car.*', 'id', 'name'];\n     *  normalize(globs)                            // ['*', '!id', '!car.model']\n     *  normalize(['!*.id', 'user.*', 'company'])   // ['company', 'user', '!company.id', '!user.id']\n     */\n    static normalize(globList, restrictive = false) {\n        const { _inspect, _covers, _intersect } = NotationGlob;\n\n        const original = utils.ensureArray(globList);\n\n        const list = original\n            // prevent mutation\n            .concat()\n            // move negated globs to top so that we inspect non-negated globs\n            // against others first. when complete, we'll sort with our\n            // .compare() function.\n            .sort(restrictive ? _negFirstSort : _negLastSort)\n            // turning string array into inspect-obj array, so that we'll not\n            // run _inspect multiple times in the inner loop. this also\n            // pre-validates each glob.\n            .map(_inspect);\n\n        // early return if we have a single item\n        if (list.length === 1) {\n            const g = list[0];\n            // single negated item is redundant\n            if (g.isNegated) return [];\n            // return normalized\n            return [g.glob];\n        }\n\n        // flag to return an empty array (in restrictive mode), if true.\n        let negateAll = false;\n\n        // we'll push keepers in this array\n        let normalized = [];\n        // we'll need to remember excluded globs, so that we can move to next\n        // item early.\n        const ignored = {};\n\n        // storage to keep intersections.\n        // using an object to prevent duplicates.\n        let intersections = {};\n\n        const checkAddIntersection = (gA, gB) => {\n            const inter = _intersect(gA, gB, restrictive);\n            if (!inter) return;\n            // if the intersection result has an inverted version in the\n            // original list, don't add this.\n            const hasInverted = restrictive ? false : original.indexOf(_invert(inter)) >= 0;\n            // also if intersection result is in the current list, don't add it.\n            if (list.indexOf(inter) >= 0 || hasInverted) return;\n            intersections[inter] = inter;\n        };\n\n        // iterate each glob by comparing it to remaining globs.\n        utils.eachRight(list, (a, indexA) => {\n\n            // if `strict` is enabled, return empty if a negate-all is found\n            // (which itself is also redundant if single): '!*' or '![*]'\n            if (re.NEGATE_ALL.test(a.glob)) {\n                negateAll = true;\n                if (restrictive) return false;\n            }\n\n            // flags\n            let duplicate = false;\n            let hasExactNeg = false;\n            // flags for negated\n            let negCoversPos = false;\n            let negCoveredByPos = false;\n            let negCoveredByNeg = false;\n            // flags for non-negated (positive)\n            let posCoversPos = false;\n            let posCoveredByNeg = false;\n            let posCoveredByPos = false;\n\n            utils.eachRight(list, (b, indexB) => {\n                // don't inspect glob with itself\n                if (indexA === indexB) return; // move to next\n                // console.log(indexA, a.glob, 'vs', b.glob);\n\n                // remove if duplicate\n                if (a.glob === b.glob) {\n                    list.splice(indexA, 1);\n                    duplicate = true;\n                    return false; // break out\n                }\n\n                // remove if positive has an exact negated (negated wins when\n                // normalized) e.g. ['*', 'a', '!a'] => ['*', '!a']\n                if (!a.isNegated && _isReverseOf(a, b)) {\n                    // list.splice(indexA, 1);\n                    ignored[a.glob] = true;\n                    hasExactNeg = true;\n                    return false; // break out\n                }\n\n                // if already excluded b, go on to next\n                if (ignored[b.glob]) return; // next\n\n                const coversB = _covers(a, b);\n                const coveredByB = coversB ? false : _covers(b, a);\n                if (a.isNegated) {\n                    if (b.isNegated) {\n                        // if negated (a) covered by any other negated (b); remove (a)!\n                        if (coveredByB) {\n                            negCoveredByNeg = true;\n                            // list.splice(indexA, 1);\n                            ignored[a.glob] = true;\n                            return false; // break out\n                        }\n                    } else {\n                        /* istanbul ignore if */\n                        if (coversB) negCoversPos = true;\n                        if (coveredByB) negCoveredByPos = true;\n                        // try intersection if none covers the other and only\n                        // one of them is negated.\n                        if (!coversB && !coveredByB) {\n                            checkAddIntersection(a.glob, b.glob);\n                        }\n                    }\n                } else {\n                    if (b.isNegated) {\n                        // if positive (a) covered by any negated (b); remove (a)!\n                        if (coveredByB) {\n                            posCoveredByNeg = true;\n                            if (restrictive) {\n                                // list.splice(indexA, 1);\n                                ignored[a.glob] = true;\n                                return false; // break out\n                            }\n                            return; // next\n                        }\n                        // try intersection if none covers the other and only\n                        // one of them is negated.\n                        if (!coversB && !coveredByB) {\n                            checkAddIntersection(a.glob, b.glob);\n                        }\n                    } else {\n                        if (coversB) posCoversPos = coversB;\n                        // if positive (a) covered by any other positive (b); remove (a)!\n                        if (coveredByB) {\n                            posCoveredByPos = true;\n                            if (restrictive) {\n                                // list.splice(indexA, 1);\n                                return false; // break out\n                            }\n                        }\n                    }\n                }\n\n            });\n\n            // const keepNeg = (negCoversPos || negCoveredByPos) && !negCoveredByNeg;\n            const keepNeg = restrictive\n                ? (negCoversPos || negCoveredByPos) && negCoveredByNeg === false\n                : negCoveredByPos && negCoveredByNeg === false;\n            const keepPos = restrictive\n                ? (posCoversPos || posCoveredByPos === false) && posCoveredByNeg === false\n                : posCoveredByNeg || posCoveredByPos === false;\n            const keep = duplicate === false\n                && hasExactNeg === false\n                && (a.isNegated ? keepNeg : keepPos);\n\n            if (keep) {\n                normalized.push(a.glob);\n            } else {\n                // this is excluded from final (normalized) list, so mark as\n                // ignored (don't remove from \"list\" for now)\n                ignored[a.glob] = true;\n            }\n        });\n\n        if (restrictive && negateAll) return [];\n\n        intersections = Object.keys(intersections);\n        if (intersections.length > 0) {\n            // merge normalized list with intersections if any\n            normalized = normalized.concat(intersections);\n            // we have new (intersection) items, so re-normalize\n            return NotationGlob.normalize(normalized, restrictive);\n        }\n\n        return NotationGlob.sort(normalized);\n    }\n\n    /**\n     *  Undocumented. See `.union()`\n     *  @private\n     *  @param {Array} globsListA -\n     *  @param {Array} globsListB -\n     *  @param {Boolean} restrictive -\n     *  @param {Array} union -\n     *  @returns {Array} -\n     */\n    static _compareUnion(globsListA, globsListB, restrictive, union = []) {\n        const { _covers } = NotationGlob;\n\n        const { _inspect, _intersect } = NotationGlob;\n\n        utils.eachRight(globsListA, globA => {\n            if (union.indexOf(globA) >= 0) return; // next\n\n            const a = _inspect(globA);\n\n            // if wildcard only, add...\n            if (re.WILDCARD.test(a.absGlob)) {\n                union.push(a.glob); // push normalized glob\n                return; // next\n            }\n\n            let notCovered = false;\n            let hasExact = false;\n            let negCoversNeg = false;\n            let posCoversNeg = false;\n            let posCoversPos = false;\n            let negCoversPos = false;\n\n            const intersections = [];\n\n            utils.eachRight(globsListB, globB => {\n\n                // keep if has exact in the other\n                if (globA === globB) hasExact = true;\n\n                const b = _inspect(globB);\n\n                // keep negated if:\n                //    1) any negated covers it\n                //    2) no positive covers it\n                // keep positive if:\n                //    1) no positive covers it OR any negated covers it\n\n                notCovered = !_covers(b, a);\n                if (notCovered) {\n                    if (a.isNegated && b.isNegated) {\n                        const inter = _intersect(a.glob, b.glob, restrictive);\n                        if (inter && union.indexOf(inter) === -1) intersections.push(inter);\n                    }\n                    return; // next\n                }\n\n                if (a.isNegated) {\n                    if (b.isNegated) {\n                        negCoversNeg = !hasExact;\n                    } else {\n                        posCoversNeg = true; // set flag\n                    }\n                } else {\n                    if (!b.isNegated) {\n                        posCoversPos = !hasExact;\n                    } else {\n                        negCoversPos = true; // set flag\n                    }\n                }\n\n            });\n\n\n            const keep = a.isNegated\n                ? (!posCoversNeg || negCoversNeg)\n                : (!posCoversPos || negCoversPos);\n\n            if (hasExact || keep || (notCovered && !a.isNegated)) {\n                union.push(a.glob); // push normalized glob\n                return;\n            }\n\n            if (a.isNegated && posCoversNeg && !negCoversNeg && intersections.length > 0) {\n                union = union.concat(intersections); // eslint-disable-line no-param-reassign\n            }\n\n        });\n\n        return union;\n    }\n\n    /**\n     *  Gets the union from the given couple of glob arrays and returns a new\n     *  array of globs.\n     *  <ul>\n     *  <li>If the exact same element is found in both\n     *  arrays, one of them is removed to prevent duplicates.\n     *  <br />example: `['!id', 'name'] ∪ ['!id']` unites to `['!id', 'name']`</li>\n     *  <li>If any non-negated item is covered by a glob in the same\n     *  or other array, the redundant item is removed.\n     *  <br />example: `['*', 'name'] ∪ ['email']` unites to `['*']`</li>\n     *  <li>If one of the arrays contains a negated equivalent of an\n     *  item in the other array, the negated item is removed.\n     *  <br />example: `['!id'] ∪ ['id']` unites to `['id']`</li>\n     *  <li>If any item covers/matches a negated item in the other array,\n     *  the negated item is removed.\n     *  <br />example #1: `['!user.id'] ∪ ['user.*']` unites to `['user']`\n     *  <br />example #2: `['*'] ∪ ['!password']` unites to `['*']`\n     *  </li>\n     *  </ul>\n     *  @name Notation.Glob.union\n     *  @function\n     *\n     *  @param {Array} globsA - First array of glob strings.\n     *  @param {Array} globsB - Second array of glob strings.\n     *  @param {Boolean} [restrictive=false] - Whether negated items in each of\n     *  the lists, strictly remove every match in themselves (not the cross\n     *  list). This option is used when pre-normalizing each glob list and\n     *  normalizing the final union list.\n     *\n     *  @returns {Array} -\n     *\n     *  @example\n     *  const a = ['user.*', '!user.email', 'car.model', '!*.id'];\n     *  const b = ['!*.date', 'user.email', 'car', '*.age'];\n     *  const { union } = Notation.Glob;\n     *  union(a, b)     // ['car', 'user', '*.age', '!car.date', '!user.id']\n     */\n    static union(globsA, globsB, restrictive) {\n        const { normalize, _compareUnion } = NotationGlob;\n\n        const listA = normalize(globsA, restrictive);\n        const listB = normalize(globsB, restrictive);\n\n        if (listA.length === 0) return listB;\n        if (listB.length === 0) return listA;\n\n        // TODO: below should be optimized\n        let union = _compareUnion(listA, listB, restrictive);\n        union = _compareUnion(listB, listA, restrictive, union);\n        return normalize(union, restrictive);\n    }\n\n}\n\n// --------------------------------\n// HELPERS\n// --------------------------------\n\nfunction _coversNote(a, b) {\n    if (a === b) return true;\n    // if (!a && re.WILDCARD.test(b)) return false;\n    const bIsArr = b ? re.ARRAY_GLOB_NOTE.test(b) : null;\n    if (a === '*' && (!b || !bIsArr)) return true;\n    if (a === '[*]' && (!b || bIsArr)) return true;\n    return false;\n}\n\n// x vs !x.*.*      » false\n// x vs !x[*]       » true\n// x[*] vs !x       » true\n// x[*] vs !x[*]    » false\n// x.* vs !x.*      » false\nfunction _isReverseOf(a, b) {\n    return a.isNegated !== b.isNegated\n        && a.absGlob === b.absGlob;\n}\n\nfunction _invert(glob) {\n    return glob[0] === '!' ? glob.slice(1) : '!' + glob;\n}\n\nconst _rx = /^\\s*!/;\nfunction _negFirstSort(a, b) {\n    return _rx.test(a) ? -1 : (_rx.test(b) ? 1 : 0);\n}\nfunction _negLastSort(a, b) {\n    return _rx.test(a) ? 1 : (_rx.test(b) ? -1 : 0);\n}\n\n// --------------------------------\n// EXPORT\n// --------------------------------\n\nexport { NotationGlob };\n","/* eslint no-use-before-define:0, consistent-return:0 */\n\nimport { NotationError } from './notation.error';\nimport { NotationGlob } from './notation.glob';\nimport { utils } from '../utils';\n\nconst ERR = {\n    SOURCE: 'Invalid source. Expected a data object or array.',\n    DEST: 'Invalid destination. Expected a data object or array.',\n    NOTATION: 'Invalid notation: ',\n    NOTA_OBJ: 'Invalid notations object. ',\n    NO_INDEX: 'Implied index does not exist: ',\n    NO_PROP: 'Implied property does not exist: '\n};\n\n// created test @ https://regex101.com/r/vLE16M/2\nconst reMATCHER = /(\\[(\\d+|\".*\"|'.*'|`.*`)\\]|[a-z$_][a-z$_\\d]*)/gi;\n// created test @ https://regex101.com/r/fL3PJt/1/\n// /^([a-z$_][a-z$_\\d]*|\\[(\\d+|\".*\"|'.*'|`.*`)\\])(\\[(\\d+|\".*\"|'.*'|`.*`)\\]|(\\.[a-z$_][a-z$_\\d]*))*$/i\nconst reVALIDATOR = new RegExp(\n    '^('\n    + '[a-z$_][a-z$_\\\\d]*'          // JS variable syntax\n    + '|'                           // OR\n    + '\\\\[(\\\\d+|\".*\"|\\'.*\\')\\\\]'    // array index or object bracket notation\n    + ')'                           // exactly once\n    + '('\n    + '\\\\[(\\\\d+|\".*\"|\\'.*\\')\\\\]'    // followed by same\n    + '|'                           // OR\n    + '\\\\.[a-z$_][a-z$_\\\\d]*'       // dot, then JS variable syntax\n    + ')*'                          // (both) may repeat any number of times\n    + '$'\n    , 'i'\n);\n\nconst DEFAULT_OPTS = Object.freeze({\n    strict: false,\n    preserveIndices: false\n});\n\n/**\n *  Notation.js for Node and Browser.\n *\n *  Like in most programming languages, JavaScript makes use of dot-notation to\n *  access the value of a member of an object (or class). `Notation` class\n *  provides various methods for modifying / processing the contents of the\n *  given object; by parsing object notation strings or globs.\n *\n *  Note that this class will only deal with enumerable properties of the source\n *  object; so it should be used to manipulate data objects. It will not deal\n *  with preserving the prototype-chain of the given object.\n *\n *  @author   Onur Yıldırım <onur@cutepilot.com>\n *  @license  MIT\n */\nclass Notation {\n\n    /**\n     *  Initializes a new instance of `Notation`.\n     *\n     *  @param {Object|Array} [source={}] - The source object (or array) to be\n     *  notated. Can either be an array or object. If omitted, defaults to an\n     *  empty object.\n     *  @param {Object} [options] - Notation options.\n     *      @param {Boolean} [options.strict=false] - Whether to throw either when\n     *      a notation path does not exist on the source (i.e. `#get()` and `#remove()`\n     *      methods); or notation path exists but overwriting is disabled (i.e.\n     *      `#set()` method). (Note that `.inspect()` and `.inspectRemove()` methods\n     *      are exceptions). It's recommended to set this to `true` and prevent silent\n     *      failures if you're working with sensitive data. Regardless of `strict` option,\n     *      it will always throw on invalid notation syntax or other crucial failures.\n     *      @param {Boolean} [options.preserveIndices=false] - Indicates whether to\n     *      preserve the indices of the parent array when an item is to be removed.\n     *      By default, the item is removed completely at the implied index instead of\n     *      preserving indices by emptying the item (sparse array). So you should mind\n     *      the shifted indices when you remove an item via `.remove()`, `.inspectRemove()`\n     *      or `.filter()`.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  const notation = new Notation(obj);\n     *  notation.get('car.model')   // » \"Charger\"\n     *  notation.remove('car.model').set('car.color', 'red').value\n     *  // » { car: { brand: \"Dodge\", year: 1970, color: \"red\" } }\n     */\n    constructor(source, options) {\n        let src = source;\n        if (arguments.length === 0) {\n            src = {};\n        } else if (!utils.isCollection(source)) {\n            throw new NotationError(ERR.SOURCE);\n        }\n\n        this.options = options;\n        this._source = src;\n        this._isArray = utils.isArray(src);\n    }\n\n    // --------------------------------\n    // INSTANCE PROPERTIES\n    // --------------------------------\n\n    /**\n     *  Gets or sets notation options.\n     *  @type {Object}\n     */\n    get options() {\n        return this._options;\n    }\n\n    set options(value) {\n        this._options = {\n            ...DEFAULT_OPTS,\n            ...(this._options || {}),\n            ...(value || {})\n        };\n    }\n\n    /**\n     *  Gets the value of the source object.\n     *  @type {Object|Array}\n     *\n     *  @example\n     *  const person = { name: \"Onur\" };\n     *  const me = Notation.create(person)\n     *      .set(\"age\", 36)\n     *      .set(\"car.brand\", \"Ford\")\n     *      .set(\"car.model\", \"Mustang\")\n     *      .value;\n     *  console.log(me); // { name: \"Onur\", age: 36, car: { brand: \"Ford\", model: \"Mustang\" } }\n     *  console.log(person === me); // true\n     */\n    get value() {\n        return this._source;\n    }\n\n    // --------------------------------\n    // INSTANCE METHODS\n    // --------------------------------\n\n    /**\n     *  Recursively iterates through each key of the source object and invokes\n     *  the given callback function with parameters, on each non-object value.\n     *\n     *  @param {Function} callback - The callback function to be invoked on\n     *  each on each non-object value. To break out of the loop, return `false`\n     *  from within the callback.\n     *  Callback signature: `callback(notation, key, value, object) { ... }`\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  Notation.create(obj).each(function (notation, key, value, object) {\n     *      console.log(notation, value);\n     *  });\n     *  // \"car.brand\"  \"Dodge\"\n     *  // \"car.model\"  \"Charger\"\n     *  // \"car.year\"  1970\n     */\n    each(callback) {\n        _each(this._source, callback);\n        return this;\n    }\n\n    /**\n     *  Iterates through each note of the given notation string by evaluating\n     *  it on the source object.\n     *\n     *  @param {String} notation - The notation string to be iterated through.\n     *  @param {Function} callback - The callback function to be invoked on\n     *  each iteration. To break out of the loop, return `false` from within\n     *  the callback. Signature: `callback(levelValue, note, index, list)`\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  Notation.create(obj)\n     *      .eachValue(\"car.brand\", function (levelValue, note, index, list) {\n     *          console.log(note, levelValue); // \"car.brand\" \"Dodge\"\n     *      });\n     */\n    eachValue(notation, callback) {\n        let level = this._source;\n        Notation.eachNote(notation, (levelNotation, note, index, list) => {\n            level = utils.hasOwn(level, note) ? level[note] : undefined;\n            if (callback(level, levelNotation, note, index, list) === false) return false;\n\n        });\n        return this;\n    }\n\n    /**\n     *  Gets the list of notations from the source object (keys).\n     *\n     *  @returns {Array} - An array of notation strings.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  const notations = Notation.create(obj).getNotations();\n     *  console.log(notations); // [ \"car.brand\", \"car.model\", \"car.year\" ]\n     */\n    getNotations() {\n        const list = [];\n        this.each(notation => {\n            list.push(notation);\n        });\n        return list;\n    }\n\n    /**\n     *  Flattens the source object to a single-level object with notated keys.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  const flat = Notation.create(obj).flatten().value;\n     *  console.log(flat);\n     *  // { \"car.brand\": \"Dodge\", \"car.model\": \"Charger\", \"car.year\": 1970 }\n     */\n    flatten() {\n        const o = {};\n        this.each((notation, key, value) => {\n            o[notation] = value;\n        });\n        this._source = o;\n        return this;\n    }\n\n    /**\n     *  Aggregates notated keys of a (single-level) object, and nests them under\n     *  their corresponding properties. This is the opposite of `Notation#flatten`\n     *  method. This might be useful when expanding a flat object fetched from\n     *  a database.\n     *  @alias Notation#aggregate\n     *  @chainable\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { \"car.brand\": \"Dodge\", \"car.model\": \"Charger\", \"car.year\": 1970 }\n     *  const expanded = Notation.create(obj).expand().value;\n     *  console.log(expanded); // { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     */\n    expand() {\n        this._source = Notation.create({}).merge(this._source).value;\n        return this;\n    }\n\n    /**\n     *  Alias for `#expand`\n     *  @private\n     *  @returns {Notation} -\n     */\n    aggregate() {\n        return this.expand();\n    }\n\n    /**\n     *  Inspects the given notation on the source object by checking\n     *  if the source object actually has the notated property;\n     *  and getting its value if exists.\n     *  @param {String} notation - The notation string to be inspected.\n     *  @returns {InspectResult} - The result object.\n     *\n     *  @example\n     *  Notation.create({ car: { year: 1970 } }).inspect(\"car.year\");\n     *  // { has: true, value: 1970, lastNote: 'year', lastNoteNormalized: 'year' }\n     *  Notation.create({ car: { year: 1970 } }).inspect(\"car.color\");\n     *  // { has: false }\n     *  Notation.create({ car: { color: undefined } }).inspect(\"car.color\");\n     *  // { has: true, value: undefined, lastNote: 'color', lastNoteNormalized: 'color' }\n     *  Notation.create({ car: { brands: ['Ford', 'Dodge'] } }).inspect(\"car.brands[1]\");\n     *  // { has: true, value: 'Dodge', lastNote: '[1]', lastNoteNormalized: 1 }\n     */\n    inspect(notation) {\n        let level = this._source;\n        let result = { has: false, value: undefined };\n        let parent;\n        Notation.eachNote(notation, (levelNotation, note) => {\n            const lastNoteNormalized = utils.normalizeNote(note);\n            if (utils.hasOwn(level, lastNoteNormalized)) {\n                level = level[lastNoteNormalized];\n                parent = level;\n                result = {\n                    notation,\n                    has: true,\n                    value: level,\n                    lastNote: note,\n                    lastNoteNormalized\n                };\n            } else {\n                // level = undefined;\n                result = {\n                    notation,\n                    has: false,\n                    lastNote: note,\n                    lastNoteNormalized\n                };\n                return false; // break out\n            }\n        });\n\n        if (parent === undefined || (result.has && parent === result.value)) parent = this._source;\n        result.parentIsArray = utils.isArray(parent);\n\n        return result;\n    }\n\n    /**\n     *  Notation inspection result object.\n     *  @typedef Notation~InspectResult\n     *  @type Object\n     *  @property {String} notation - Notation that is inspected.\n     *  @property {Boolean} has - Indicates whether the source object has the\n     *  given notation as a (leveled) enumerable property. If the property\n     *  exists but has a value of `undefined`, this will still return `true`.\n     *  @property {*} value - The value of the notated property. If the source\n     *  object does not have the notation, the value will be `undefined`.\n     *  @property {String} lastNote - Last note of the notation, if actually\n     *  exists. For example, last note of `'a.b.c'` is `'c'`.\n     *  @property {String|Number} lastNoteNormalized - Normalized representation\n     *  of the last note of the notation, if actually exists. For example, last\n     *  note of `'a.b[1]` is `'[1]'` and will be normalized to number `1`; which\n     *  indicates an array index.\n     *  @property {Boolean} parentIsArray - Whether the parent object of the\n     *  notation path is an array.\n     */\n\n    /**\n     *  Inspects and removes the given notation from the source object by\n     *  checking if the source object actually has the notated property; and\n     *  getting its value if exists, before removing the property.\n     *\n     *  @param {String} notation - The notation string to be inspected.\n     *\n     *  @returns {InspectResult} - The result object.\n     *\n     *  @example\n     *  let obj = { name: \"John\", car: { year: 1970 } };\n     *  let result = Notation.create(obj).inspectRemove(\"car.year\");\n     *  // result » { notation: \"car.year\", has: true, value: 1970, lastNote: \"year\", lastNoteNormalized: \"year\" }\n     *  // obj » { name: \"John\", car: {} }\n     *\n     *  result = Notation.create({ car: { year: 1970 } }).inspectRemove(\"car.color\");\n     *  // result » { notation: \"car.color\", has: false }\n     *  Notation.create({ car: { color: undefined } }).inspectRemove(\"car['color']\");\n     *  // { notation: \"car.color\", has: true, value: undefined, lastNote: \"['color']\", lastNoteNormalized: \"color\" }\n     *\n     *  let obj = { car: { colors: [\"black\", \"white\"] } };\n     *  let result = Notation.create().inspectRemove(\"car.colors[0]\");\n     *  // result » { notation: \"car.colors[0]\", has: true, value: \"black\", lastNote: \"[0]\", lastNoteNormalized: 0 }\n     *  // obj » { car: { colors: [(empty), \"white\"] } }\n     */\n    inspectRemove(notation) {\n        if (!notation) throw new Error(ERR.NOTATION + `'${notation}'`);\n        const parentNotation = Notation.parent(notation);\n        const parent = parentNotation ? this.get(parentNotation, null) : this._source;\n        const parentIsArray = utils.isArray(parent);\n        const lastNote = Notation.last(notation);\n        const lastNoteNormalized = utils.normalizeNote(lastNote);\n\n        let result;\n        if (utils.hasOwn(parent, lastNoteNormalized)) {\n            result = {\n                notation,\n                has: true,\n                value: parent[lastNoteNormalized],\n                lastNote,\n                lastNoteNormalized,\n                parentIsArray\n            };\n\n            // if `preserveIndices` is enabled and this is an array, we'll\n            // splice the item out. otherwise, we'll use `delete` syntax to\n            // empty the item.\n            if (!this.options.preserveIndices && parentIsArray) {\n                parent.splice(lastNoteNormalized, 1);\n            } else {\n                delete parent[lastNoteNormalized];\n            }\n        } else {\n            result = {\n                notation,\n                has: false,\n                lastNote,\n                lastNoteNormalized,\n                parentIsArray\n            };\n        }\n\n        return result;\n    }\n\n    /**\n     *  Checks whether the source object has the given notation\n     *  as a (leveled) enumerable property. If the property exists\n     *  but has a value of `undefined`, this will still return `true`.\n     *  @param {String} notation - The notation string to be checked.\n     *  @returns {Boolean} -\n     *\n     *  @example\n     *  Notation.create({ car: { year: 1970 } }).has(\"car.year\"); // true\n     *  Notation.create({ car: { year: undefined } }).has(\"car.year\"); // true\n     *  Notation.create({}).has(\"car.color\"); // false\n     */\n    has(notation) {\n        return this.inspect(notation).has;\n    }\n\n    /**\n     *  Checks whether the source object has the given notation\n     *  as a (leveled) defined enumerable property. If the property\n     *  exists but has a value of `undefined`, this will return `false`.\n     *  @param {String} notation - The notation string to be checked.\n     *  @returns {Boolean} -\n     *\n     *  @example\n     *  Notation.create({ car: { year: 1970 } }).hasDefined(\"car.year\"); // true\n     *  Notation.create({ car: { year: undefined } }).hasDefined(\"car.year\"); // false\n     *  Notation.create({}).hasDefined(\"car.color\"); // false\n     */\n    hasDefined(notation) {\n        return this.inspect(notation).value !== undefined;\n    }\n\n    /**\n     *  Gets the value of the corresponding property at the given notation.\n     *\n     *  @param {String} notation - The notation string to be processed.\n     *  @param {String} [defaultValue] - The default value to be returned if the\n     *  property is not found or enumerable.\n     *\n     *  @returns {*} - The value of the notated property.\n     *  @throws {NotationError} - If `strict` option is enabled, `defaultValue`\n     *  is not set and notation does not exist.\n     *\n     *  @example\n     *  Notation.create({ car: { brand: \"Dodge\" } }).get(\"car.brand\"); // \"Dodge\"\n     *  Notation.create({ car: {} }).get(\"car.model\", \"Challenger\"); // \"Challenger\"\n     *  Notation.create({ car: { model: undefined } }).get(\"car.model\", \"Challenger\"); // undefined\n     *\n     *  @example <caption>get value when strict option is enabled</caption>\n     *  // strict option defaults to false\n     *  Notation.create({ car: {} }).get(\"car.model\"); // undefined\n     *  Notation.create({ car: {} }, { strict: false }).get(\"car.model\"); // undefined\n     *  // below will throw bec. strict = true, car.model does not exist\n     *  // and no default value is given.\n     *  Notation.create({ car: {} }, { strict: true }).get(\"car.model\");\n     */\n    get(notation, defaultValue) {\n        const result = this.inspect(notation);\n        // if strict and no default value is set, check if implied index or prop\n        // exists\n        if (this.options.strict && arguments.length < 2 && !result.has) {\n            const msg = result.parentIsArray ? ERR.NO_INDEX : ERR.NO_PROP;\n            throw new NotationError(msg + `'${notation}'`);\n        }\n        return result.has ? result.value : defaultValue;\n    }\n\n    /**\n     *  Sets the value of the corresponding property at the given notation. If\n     *  the property does not exist, it will be created and nested at the\n     *  calculated level. If it exists; its value will be overwritten by\n     *  default.\n     *  @chainable\n     *\n     *  @param {String} notation - The notation string to be processed.\n     *  @param {*} value - The value to be set for the notated property.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property if\n     *  exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @throws {NotationError} - If strict notation is enabled, `overwrite`\n     *  option is set to `false` and attempted to overwrite an existing value.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", year: 1970 } };\n     *  Notation.create(obj)\n     *      .set(\"car.brand\", \"Ford\")\n     *      .set(\"car.model\", \"Mustang\")\n     *      .set(\"car.year\", 1965, false)\n     *      .set(\"car.color\", \"red\")\n     *      .set(\"boat\", \"none\");\n     *  console.log(obj);\n     *  // { notebook: \"Mac\", car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" }, boat: \"none\" };\n     */\n    set(notation, value, overwrite = true) {\n        if (!notation.trim()) throw new NotationError(ERR.NOTATION + `'${notation}'`);\n\n        let level = this._source;\n        let currentIsLast, nCurrentNote, nNextNote, nextIsArrayNote;\n\n        Notation.eachNote(notation, (levelNotation, note, index, list) => {\n            currentIsLast = index === list.length - 1;\n            nCurrentNote = nNextNote || utils.normalizeNote(note);\n            nNextNote = currentIsLast ? null : utils.normalizeNote(list[index + 1]);\n\n            if (utils.isArray(level) && typeof nCurrentNote !== 'number') {\n                const parent = Notation.parent(levelNotation) || 'source';\n                throw new NotationError(`Cannot set string key '${note}' on array ${parent}`);\n            }\n\n            // check if the property is at this level\n            if (utils.hasOwn(level, nCurrentNote)) {\n                // check if we're at the last level\n                if (currentIsLast) {\n                    // if overwrite is set, assign the value.\n                    if (overwrite) {\n                        level[nCurrentNote] = value;\n                    } else if (this.options.strict) {\n                        throw new NotationError('Cannot overwrite an existing value in strict mode.');\n                    }\n                } else {\n                    // if not, just re-reference the current level.\n                    level = level[nCurrentNote];\n                }\n            } else {\n                // if next normalized note is a number, it indicates that the\n                // current note is actually an array.\n                nextIsArrayNote = typeof nNextNote === 'number';\n\n                // we don't have this property at this level so; if this is the\n                // last level, we set the value if not, we set an empty\n                // collection for the next level\n                level[nCurrentNote] = (currentIsLast ? value : (nextIsArrayNote ? [] : {}));\n                level = level[nCurrentNote];\n            }\n        });\n        return this;\n    }\n\n    /**\n     *  Just like the `.set()` method but instead of a single notation\n     *  string, an object of notations and values can be passed.\n     *  Sets the value of each corresponding property at the given\n     *  notation. If a property does not exist, it will be created\n     *  and nested at the calculated level. If it exists; its value\n     *  will be overwritten by default.\n     *  @chainable\n     *\n     *  @param {Object} notationsObject - The notations object to be processed.\n     *  This can either be a regular object with non-dotted keys\n     *  (which will be merged to the first/root level of the source object);\n     *  or a flattened object with notated (dotted) keys.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite a property if\n     *  exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", year: 1970 } };\n     *  Notation.create(obj).merge({\n     *      \"car.brand\": \"Ford\",\n     *      \"car.model\": \"Mustang\",\n     *      \"car.year\": 1965,\n     *      \"car.color\": \"red\",\n     *      \"boat\": \"none\"\n     *  });\n     *  console.log(obj);\n     *  // { car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" }, boat: \"none\" };\n     */\n    merge(notationsObject, overwrite = true) {\n        if (!utils.isObject(notationsObject)) {\n            throw new NotationError(ERR.NOTA_OBJ + 'Expected an object.');\n        }\n        let value;\n        utils.each(Object.keys(notationsObject), notation => {\n            value = notationsObject[notation];\n            this.set(notation, value, overwrite);\n        });\n        return this;\n    }\n\n    /**\n     *  Removes the properties by the given list of notations from the source\n     *  object and returns a new object with the removed properties.\n     *  Opposite of `merge()` method.\n     *\n     *  @param {Array} notations - The notations array to be processed.\n     *\n     *  @returns {Object} - An object with the removed properties.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", year: 1970 }, notebook: \"Mac\" };\n     *  const separated = Notation.create(obj).separate([\"car.brand\", \"boat\" ]);\n     *  console.log(separated);\n     *  // { notebook: \"Mac\", car: { brand: \"Ford\" } };\n     *  console.log(obj);\n     *  // { car: { year: 1970 } };\n     */\n    separate(notations) {\n        if (!utils.isArray(notations)) {\n            throw new NotationError(ERR.NOTA_OBJ + 'Expected an array.');\n        }\n        const o = new Notation({});\n        utils.each(notations, notation => {\n            const result = this.inspectRemove(notation);\n            o.set(notation, result.value);\n        });\n        this._source = o._source;\n        return this;\n    }\n\n    /**\n     *  Deep clones the source object while filtering its properties by the\n     *  given <b>glob</b> notations. Includes all matched properties and removes\n     *  the rest.\n     *\n     *  The difference between regular notations and glob-notations is that;\n     *  with the latter, you can use wildcard stars (*) and negate the notation\n     *  by prepending a bang (!). A negated notation will be excluded.\n     *\n     *  Order of the globs does not matter; they will be logically sorted. Loose\n     *  globs will be processed first and verbose globs or normal notations will\n     *  be processed last. e.g. `[ \"car.model\", \"*\", \"!car.*\" ]` will be\n     *  normalized and sorted as `[ \"*\", \"!car\" ]`.\n     *\n     *  Passing no parameters or passing an empty string (`\"\"` or `[\"\"]`) will\n     *  empty the source object. See `Notation.Glob` class for more information.\n     *\n     *  @param {Array|String} globNotations - Glob notation(s) to be processed.\n     *  @chainable\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self). To\n     *  get the filtered value, call `.value` property on the instance.\n     *\n     *  @example\n     *  const obj = { notebook: \"Mac\", car: { brand: \"Ford\", model: \"Mustang\", year: 1970 } };\n     *  const n = Notation.create(obj);\n     *  n.filter([ \"*\", \"!car.year\" ])\n     *  console.log(obj)            // { notebook: \"Mac\", car: { brand: \"Ford\", model: \"Mustang\" } }\n     *  n.filter(\"car.brand\").value // { car: { brand: \"Ford\" } }\n     *  console.log(obj)            // { notebook: \"Mac\", car: { model: \"Mustang\" } }\n     *  n.filter().value            // {}\n     *                              // equivalent to n.filter(\"\") or n.filter(\"!*\")\n     */\n    filter(globNotations) {\n        const original = this.value;\n        const copy = utils.deepCopy(original);\n        const { re } = utils;\n\n        // ensure array, normalize and sort the globs in logical order. this\n        // also concats the array first (to prevent mutating the original\n        // array).\n        const globs = NotationGlob.normalize(globNotations);\n        const len = globs.length;\n        const empty = this._isArray ? [] : {};\n\n        // if globs is \"\" or [\"\"] set source to empty and return.\n        if (len === 0 || (len === 1 && (!globs[0] || re.NEGATE_ALL.test(globs[0])))) {\n            this._source = empty;\n            return this;\n        }\n\n        const firstIsWildcard = re.WILDCARD.test(globs[0]);\n        // if globs only consist of \"*\" or \"[*]\"; set the \"copy\" as source and\n        // return.\n        if (len === 1 && firstIsWildcard) {\n            this._source = copy;\n            return this;\n        }\n\n        let filtered;\n        // if the first item of sorted globs is \"*\" or \"[*]\" we set the source\n        // to the (full) \"copy\" and remove the wildcard from globs (not to\n        // re-process).\n        if (firstIsWildcard) {\n            filtered = new Notation(copy);\n            globs.shift();\n        } else {\n            // otherwise we set an empty object or array as the source so that\n            // we can add notations/properties to it.\n            filtered = new Notation(empty);\n        }\n\n        let g, endStar, normalized;\n        // iterate through globs\n        utils.each(globs, globNotation => {\n            g = new NotationGlob(globNotation);\n            // set flag that indicates whether the glob ends with `.*`\n            endStar = g.absGlob.slice(-2) === '.*';\n            // get the remaining part as the (extra) normalized glob\n            normalized = endStar ? g.absGlob.slice(0, -2) : g.absGlob;\n            // normalized = endStar ? g.absGlob.replace(/(\\.\\*)+$/, '') : g.absGlob;\n            // check if normalized glob has no wildcard stars e.g. \"a.b\" or\n            // \"!a.b.c\" etc..\n            if (normalized.indexOf('*') < 0) {\n                if (g.isNegated) {\n                    // directly remove the notation if negated\n                    filtered.remove(normalized);\n                    // if original glob had `.*` at the end, it means remove\n                    // contents (not itself). so we'll set an empty object.\n                    // meaning `some.prop` (prop) is removed completely but\n                    // `some.prop.*` (prop) results in `{}`.\n                    if (endStar) filtered.set(normalized, {}, true);\n                } else {\n                    // directly copy the same notation from the original\n                    filtered.copyFrom(original, normalized, null, true);\n                }\n                // move to the next\n                return true;\n            }\n            // if glob has wildcard star(s), we'll iterate through keys of the\n            // source object and see if (full) notation of each key matches\n            // the current glob.\n\n            // TODO: Optimize the loop below. Instead of checking each key's\n            // notation, get the non-star left part of the glob and iterate\n            // that property of the source object.\n            this.each((originalNotation, key, value) => {\n                // console.log('>>', originalNotation);\n\n                // iterating each note of original notation. i.e.:\n                // note1.note2.note3 is iterated from left to right, as:\n                // 'note1', 'note1.note2', 'note1.note2.note3' — in order.\n                Notation.eachNote(originalNotation, levelNotation => {\n                    if (g.test(levelNotation)) {\n                        if (g.isNegated) {\n                            // console.log('removing', levelNotation, 'of', originalNotation);\n                            filtered.remove(levelNotation);\n                            // we break and return early if removed bec. deeper\n                            // level props are also removed with this parent.\n                            // e.g. when 'note1.note2' of 'note1.note2.note3' is\n                            // removed, we no more have 'note3'.\n                            return false;\n                        }\n                        filtered.set(levelNotation, value, true);\n                    }\n                });\n            });\n        });\n        // finally set the filtered's value as the source of our instance and\n        // return.\n        this._source = filtered.value;\n        return this;\n    }\n\n    /**\n     *  Removes the property from the source object, at the given notation.\n     *  @alias Notation#delete\n     *  @chainable\n     *  @param {String} notation - The notation to be inspected.\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *  @throws {NotationError} - If `strict` option is enabled and notation\n     *  does not exist.\n     *\n     *  @example\n     *  const obj = { notebook: \"Mac\", car: { model: \"Mustang\" } };\n     *  Notation.create(obj).remove(\"car.model\");\n     *  console.log(obj); // { notebook: \"Mac\", car: { } }\n     */\n    remove(notation) {\n        const result = this.inspectRemove(notation);\n        // if strict, check if implied index or prop exists\n        if (this.options.strict && !result.has) {\n            const msg = result.parentIsArray ? ERR.NO_INDEX : ERR.NO_PROP;\n            throw new NotationError(msg + `'${notation}'`);\n        }\n        return this;\n    }\n\n    /**\n     *  Alias of `Notation#remove`\n     *  @private\n     *  @param {String} notation -\n     *  @returns {Notation} -\n     */\n    delete(notation) {\n        this.remove(notation);\n        return this;\n    }\n\n    /**\n     *  Clones the `Notation` instance to a new one.\n     *  @returns {Notation} - A new copy of the instance.\n     */\n    clone() {\n        return new Notation(utils.deepCopy(this.value));\n    }\n\n    /**\n     *  Copies the notated property from the source collection and adds it to the\n     *  destination — only if the source object actually has that property.\n     *  This is different than a property with a value of `undefined`.\n     *  @chainable\n     *\n     *  @param {Object|Array} destination - The destination object that the notated\n     *  properties will be copied to.\n     *  @param {String} notation - The notation to get the corresponding property\n     *  from the source object.\n     *  @param {String} [newNotation=null] - The notation to set the source property\n     *  on the destination object. In other words, the copied property will be\n     *  renamed to this value before set on the destination object. If not set,\n     *  `notation` argument will be used.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\n     *  the destination object if it exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @throws {NotationError} - If `destination` is not a valid collection.\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const models = { dodge: \"Charger\" };\n     *  Notation.create(obj).copyTo(models, \"car.model\", \"ford\");\n     *  console.log(models);\n     *  // { dodge: \"Charger\", ford: \"Mustang\" }\n     *  // source object (obj) is not modified\n     */\n    copyTo(destination, notation, newNotation = null, overwrite = true) {\n        if (!utils.isCollection(destination)) throw new NotationError(ERR.DEST);\n        const result = this.inspect(notation);\n        if (result.has) {\n            const newN = utils.getNewNotation(newNotation, notation);\n            new Notation(destination).set(newN, result.value, overwrite);\n        }\n        return this;\n    }\n\n    /**\n     *  Copies the notated property from the target collection and adds it to\n     *  (own) source object — only if the target object actually has that\n     *  property. This is different than a property with a value of `undefined`.\n     *  @chainable\n     *\n     *  @param {Object|Array} target - The target collection that the notated\n     *  properties will be copied from.\n     *  @param {String} notation - The notation to get the corresponding\n     *  property from the target object.\n     *  @param {String} [newNotation=null] - The notation to set the copied\n     *  property on our source collection. In other words, the copied property\n     *  will be renamed to this value before set. If not set, `notation`\n     *  argument will be used.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\n     *  our collection if it exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @throws {NotationError} - If `target` is not a valid collection.\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const models = { dodge: \"Charger\" };\n     *  Notation.create(obj).copyFrom(models, \"dodge\", \"car.model\", true);\n     *  console.log(obj);\n     *  // { car: { brand: \"Ford\", model: \"Charger\" } }\n     *  // models object is not modified\n     */\n    copyFrom(target, notation, newNotation = null, overwrite = true) {\n        if (!utils.isCollection(target)) throw new NotationError(ERR.DEST);\n        const result = new Notation(target).inspect(notation);\n        if (result.has) {\n            const newN = utils.getNewNotation(newNotation, notation);\n            this.set(newN, result.value, overwrite);\n        }\n        return this;\n    }\n\n    /**\n     *  Removes the notated property from the source (own) collection and adds\n     *  it to the destination — only if the source collection actually has that\n     *  property. This is different than a property with a value of `undefined`.\n     *  @chainable\n     *\n     *  @param {Object|Array} destination - The destination collection that the\n     *  notated properties will be moved to.\n     *  @param {String} notation - The notation to get the corresponding\n     *  property from the source object.\n     *  @param {String} [newNotation=null] - The notation to set the source\n     *  property on the destination object. In other words, the moved property\n     *  will be renamed to this value before set on the destination object. If\n     *  not set, `notation` argument will be used.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\n     *  the destination object if it exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @throws {NotationError} - If `destination` is not a valid collection.\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const models = { dodge: \"Charger\" };\n     *  Notation.create(obj).moveTo(models, \"car.model\", \"ford\");\n     *  console.log(obj);\n     *  // { car: { brand: \"Ford\" } }\n     *  console.log(models);\n     *  // { dodge: \"Charger\", ford: \"Mustang\" }\n     */\n    moveTo(destination, notation, newNotation = null, overwrite = true) {\n        if (!utils.isCollection(destination)) throw new NotationError(ERR.DEST);\n        const result = this.inspectRemove(notation);\n        if (result.has) {\n            const newN = utils.getNewNotation(newNotation, notation);\n            new Notation(destination).set(newN, result.value, overwrite);\n        }\n        return this;\n    }\n\n    /**\n     *  Removes the notated property from the target collection and adds it to (own)\n     *  source collection — only if the target object actually has that property.\n     *  This is different than a property with a value of `undefined`.\n     *  @chainable\n     *\n     *  @param {Object|Array} target - The target collection that the notated\n     *  properties will be moved from.\n     *  @param {String} notation - The notation to get the corresponding property\n     *  from the target object.\n     *  @param {String} [newNotation=null] - The notation to set the target\n     *  property on the source object. In other words, the moved property\n     *  will be renamed to this value before set on the source object.\n     *  If not set, `notation` argument will be used.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\n     *  the source object if it exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @throws {NotationError} - If `target` is not a valid collection.\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const models = { dodge: \"Charger\" };\n     *  Notation.create(obj).moveFrom(models, \"dodge\", \"car.model\", true);\n     *  console.log(obj);\n     *  // { car: { brand: \"Ford\", model: \"Charger\" } }\n     *  console.log(models);\n     *  // {}\n     */\n    moveFrom(target, notation, newNotation = null, overwrite = true) {\n        if (!utils.isCollection(target)) throw new NotationError(ERR.DEST);\n        const result = new Notation(target).inspectRemove(notation);\n        if (result.has) {\n            const newN = utils.getNewNotation(newNotation, notation);\n            this.set(newN, result.value, overwrite);\n        }\n        return this;\n    }\n\n    /**\n     *  Renames the notated property of the source collection by the new notation.\n     *  @alias Notation#renote\n     *  @chainable\n     *\n     *  @param {String} notation - The notation to get the corresponding\n     *  property (value) from the source collection.\n     *  @param {String} newNotation - The new notation for the targeted\n     *  property value. If not set, the source collection will not be modified.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property at\n     *  the new notation, if it exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  Notation.create(obj)\n     *      .rename(\"car.brand\", \"carBrand\")\n     *      .rename(\"car.model\", \"carModel\");\n     *  console.log(obj);\n     *  // { carBrand: \"Ford\", carModel: \"Mustang\" }\n     */\n    rename(notation, newNotation, overwrite) {\n        return this.moveTo(this._source, notation, newNotation, overwrite);\n    }\n\n    /**\n     *  Alias for `#rename`\n     *  @private\n     *  @param {String} notation -\n     *  @param {String} newNotation -\n     *  @param {Boolean} [overwrite=true] -\n     *  @returns {Notation} -\n     */\n    renote(notation, newNotation, overwrite) {\n        return this.rename(notation, newNotation, overwrite);\n    }\n\n    /**\n     *  Extracts the property at the given notation to a new object by copying\n     *  it from the source collection. This is equivalent to `.copyTo({},\n     *  notation, newNotation)`.\n     *  @alias Notation#copyToNew\n     *\n     *  @param {String} notation - The notation to get the corresponding\n     *  property (value) from the source object.\n     *  @param {String} newNotation - The new notation to be set on the new\n     *  object for the targeted property value. If not set, `notation` argument\n     *  will be used.\n     *\n     *  @returns {Object} - Returns a new object with the notated property.\n     *\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const extracted = Notation.create(obj).extract(\"car.brand\", \"carBrand\");\n     *  console.log(extracted);\n     *  // { carBrand: \"Ford\" }\n     *  // obj is not modified\n     */\n    extract(notation, newNotation) {\n        const o = {};\n        this.copyTo(o, notation, newNotation);\n        return o;\n    }\n\n    /**\n     *  Alias for `#extract`\n     *  @private\n     *  @param {String} notation -\n     *  @param {String} newNotation -\n     *  @returns {Object} -\n     */\n    copyToNew(notation, newNotation) {\n        return this.extract(notation, newNotation);\n    }\n\n    /**\n     *  Extrudes the property at the given notation to a new collection by\n     *  moving it from the source collection. This is equivalent to `.moveTo({},\n     *  notation, newNotation)`.\n     *  @alias Notation#moveToNew\n     *\n     *  @param {String} notation - The notation to get the corresponding\n     *  property (value) from the source object.\n     *  @param {String} newNotation - The new notation to be set on the new\n     *  object for the targeted property value. If not set, `notation` argument\n     *  will be used.\n     *\n     *  @returns {Object} - Returns a new object with the notated property.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const extruded = Notation.create(obj).extrude(\"car.brand\", \"carBrand\");\n     *  console.log(obj);\n     *  // { car: { model: \"Mustang\" } }\n     *  console.log(extruded);\n     *  // { carBrand: \"Ford\" }\n     */\n    extrude(notation, newNotation) {\n        const o = {};\n        this.moveTo(o, notation, newNotation);\n        return o;\n    }\n\n    /**\n     *  Alias for `#extrude`\n     *  @private\n     *  @param {String} notation -\n     *  @param {String} newNotation -\n     *  @returns {Object} -\n     */\n    moveToNew(notation, newNotation) {\n        return this.extrude(notation, newNotation);\n    }\n\n    // --------------------------------\n    // STATIC MEMBERS\n    // --------------------------------\n\n    /**\n     *  Basically constructs a new `Notation` instance.\n     *  @chainable\n     *  @param {Object|Array} [source={}] - The source collection to be notated.\n     *  @param {Object} [options] - Notation options.\n     *      @param {Boolean} [options.strict=false] - Whether to throw when a\n     *      notation path does not exist on the source. (Note that `.inspect()`\n     *      and `.inspectRemove()` methods are exceptions). It's recommended to\n     *      set this to `true` and prevent silent failures if you're working\n     *      with sensitive data. Regardless of `strict` option, it will always\n     *      throw on invalid notation syntax or other crucial failures.\n     *      @param {Boolean} [options.preserveIndices=true] - Indicates whether to\n     *      preserve the indices of the parent array when an item is to be removed.\n     *      By default indices are preserved by emptying the item (sparse array),\n     *      instead of removing the item completely at the index. When this is\n     *      disabled; you should mind the shifted indices when you remove an\n     *      item via `.remove()`, `.inspectRemove()` or `.filter()`.\n     *\n     *  @returns {Notation} - The created instance.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  const notation = Notation.create(obj); // equivalent to new Notation(obj)\n     *  notation.get('car.model')   // » \"Charger\"\n     *  notation.remove('car.model').set('car.color', 'red').value\n     *  // » { car: { brand: \"Dodge\", year: 1970, color: \"red\" } }\n     */\n    static create(source, options) {\n        if (arguments.length === 0) {\n            return new Notation({});\n        }\n        return new Notation(source, options);\n    }\n\n    /**\n     *  Checks whether the given notation string is valid. Note that the star\n     *  (`*`) (which is a valid character, even if irregular) is NOT treated as\n     *  wildcard here. This checks for regular dot-notation, not a glob-notation.\n     *  For glob notation validation, use `Notation.Glob.isValid()` method. Same\n     *  goes for the negation character/prefix (`!`).\n     *\n     *  @param {String} notation - The notation string to be checked.\n     *  @returns {Boolean} -\n     *\n     *  @example\n     *  Notation.isValid('prop1.prop2.prop3'); // true\n     *  Notation.isValid('x'); // true\n     *  Notation.isValid('x.arr[0].y'); // true\n     *  Notation.isValid('x[\"*\"]'); // true\n     *  Notation.isValid('x.*'); // false (this would be valid for Notation#filter() only or Notation.Glob class)\n     *  Notation.isValid('@1'); // false (should be \"['@1']\")\n     *  Notation.isValid(null); // false\n     */\n    static isValid(notation) {\n        return typeof notation === 'string' && reVALIDATOR.test(notation);\n    }\n\n    /**\n     *  Splits the given notation string into its notes (levels).\n     *  @param {String} notation  Notation string to be splitted.\n     *  @returns {Array} - A string array of notes (levels).\n     *  @throws {NotationError} - If given notation is invalid.\n     */\n    static split(notation) {\n        if (!Notation.isValid(notation)) {\n            throw new NotationError(ERR.NOTATION + `'${notation}'`);\n        }\n        return notation.match(reMATCHER);\n    }\n\n    /**\n     *  Joins the given notes into a notation string.\n     *  @param {String} notes  Notes (levels) to be joined.\n     *  @returns {String}  Joined notation string.\n     */\n    static join(notes) {\n        return utils.joinNotes(notes);\n    }\n\n    /**\n     *  Counts the number of notes/levels in the given notation.\n     *  @alias Notation.countLevels\n     *  @param {String} notation - The notation string to be processed.\n     *  @returns {Number} - Number of notes.\n     *  @throws {NotationError} - If given notation is invalid.\n     */\n    static countNotes(notation) {\n        return Notation.split(notation).length;\n    }\n\n    /**\n     *  Alias of `Notation.countNotes`.\n     *  @private\n     *  @param {String} notation -\n     *  @returns {Number} -\n     */\n    static countLevels(notation) {\n        return Notation.countNotes(notation);\n    }\n\n    /**\n     *  Gets the first (root) note of the notation string.\n     *  @param {String} notation - The notation string to be processed.\n     *  @returns {String} - First note.\n     *  @throws {NotationError} - If given notation is invalid.\n     *\n     *  @example\n     *  Notation.first('first.prop2.last'); // \"first\"\n     */\n    static first(notation) {\n        return Notation.split(notation)[0];\n    }\n\n    /**\n     *  Gets the last note of the notation string.\n     *  @param {String} notation - The notation string to be processed.\n     *  @returns {String} - Last note.\n     *  @throws {NotationError} - If given notation is invalid.\n     *\n     *  @example\n     *  Notation.last('first.prop2.last'); // \"last\"\n     */\n    static last(notation) {\n        const list = Notation.split(notation);\n        return list[list.length - 1];\n    }\n\n    /**\n     *  Gets the parent notation (up to but excluding the last note)\n     *  from the notation string.\n     *  @param {String} notation - The notation string to be processed.\n     *  @returns {String} - Parent note if any. Otherwise, `null`.\n     *  @throws {NotationError} - If given notation is invalid.\n     *\n     *  @example\n     *  Notation.parent('first.prop2.last'); // \"first.prop2\"\n     *  Notation.parent('single'); // null\n     */\n    static parent(notation) {\n        const last = Notation.last(notation);\n        return notation.slice(0, -last.length).replace(/\\.$/, '') || null;\n    }\n\n    /**\n     *  Iterates through each note/level of the given notation string.\n     *  @alias Notation.eachLevel\n     *\n     *  @param {String} notation - The notation string to be iterated through.\n     *  @param {Function} callback - The callback function to be invoked on\n     *  each iteration. To break out of the loop, return `false` from within the\n     *  callback.\n     *  Callback signature: `callback(levelNotation, note, index, list) { ... }`\n     *\n     *  @returns {void}\n     *  @throws {NotationError} - If given notation is invalid.\n     *\n     *  @example\n     *  const notation = 'first.prop2.last';\n     *  Notation.eachNote(notation, function (levelNotation, note, index, list) {\n     *      console.log(index, note, levelNotation);\n     *  });\n     *  // 0  \"first\"             \"first\"\n     *  // 1  \"first.prop2\"       \"prop2\"\n     *  // 2  \"first.prop2.last\"  \"last\"\n     */\n    static eachNote(notation, callback) {\n        const notes = Notation.split(notation);\n        const levelNotes = [];\n        utils.each(notes, (note, index) => {\n            levelNotes.push(note);\n            if (callback(Notation.join(levelNotes), note, index, notes) === false) return false;\n        }, Notation);\n    }\n\n    /**\n     *  Alias of `Notation.eachNote`.\n     *  @private\n     *  @param {String} notation -\n     *  @param {Function} callback -\n     *  @returns {void}\n     */\n    static eachLevel(notation, callback) {\n        Notation.eachNote(notation, callback);\n    }\n\n}\n\n/**\n *  Error class specific to `Notation`.\n *  @private\n *\n *  @class\n *  @see `{@link #Notation.Error}`\n */\nNotation.Error = NotationError;\n\n/**\n *  Utility for validating, comparing and sorting dot-notation globs.\n *  This is internally used by `Notation` class.\n *  @private\n *\n *  @class\n *  @see `{@link #Notation.Glob}`\n */\nNotation.Glob = NotationGlob;\n\n/**\n *  Undocumented\n *  @private\n */\nNotation.utils = utils;\n\n// --------------------------------\n// HELPERS\n// --------------------------------\n\n/**\n *  Deep iterates through each note (level) of each item in the given\n *  collection.\n *  @private\n *  @param {Object|Array} collection  A data object or an array, as the source.\n *  @param {Function} callback  A function to be executed on each iteration,\n *  with the following arguments: `(levelNotation, note, value, collection)`\n *  @param {String} parentNotation  Storage for parent (previous) notation.\n *  @param {Collection} topSource  Storage for initial/main collection.\n *  @param {Boolean} [byLevel=false]  Indicates whether to iterate notations by\n *  each level or by the end value.  For example, if we have a collection of\n *  `{a: { b: true } }`, and `byLevel` is set; the callback will be invoked on\n *  the following notations: `a`, `a.b`. Otherwise, it will be invoked only on\n *  `a.b`.\n *  @returns {void}\n */\nfunction _each(collection, callback, parentNotation, topSource, byLevel = false) { // eslint-disable-line max-params\n    const source = topSource || collection;\n    // if (!utils.isCollection(collection)) throw ... // no need\n    utils.eachItem(collection, (value, keyOrIndex) => {\n        const note = typeof keyOrIndex === 'number'\n            ? `[${keyOrIndex}]`\n            : keyOrIndex;\n        const currentNotation = Notation.join([parentNotation, note]);\n        const isCollection = utils.isCollection(value);\n        // if it's not a collection we'll execute the callback. if it's a\n        // collection but byLevel is set, we'll also execute the callback.\n        if (!isCollection || byLevel) {\n            if (callback(currentNotation, note, value, source) === false) return false;\n        }\n        // deep iterating if collection\n        if (isCollection) _each(value, callback, currentNotation, source, byLevel);\n    });\n}\n\n// --------------------------------\n// EXPORT\n// --------------------------------\n\nexport { Notation };\n","/* istanbul ignore file */\nexport * from './core/notation';\n"],"sourceRoot":""}