{"version":3,"sources":["webpack://notation/webpack/universalModuleDefinition","webpack://notation/webpack/bootstrap","webpack://notation/./src/core/notation.error.js","webpack://notation/./src/utils.js","webpack://notation/./src/core/notation.glob.js","webpack://notation/./src/core/notation.js"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","m","setProto","Object","setPrototypeOf","NotationError","Error","message","prototype","defineProperty","enumerable","writable","value","hasOwnProperty","captureStackTrace","stack","objProto","symValueOf","Symbol","valueOf","VAR","ARRAY_NOTE","OBJECT_BRACKETS","NON_NEG_WILDCARD_TRAIL","_reFlags","utils","re","ARRAY_GLOB_NOTE","WILDCARD","WILDCARDS","NEGATE_ALL","type","o","toString","call","match","toLowerCase","isCollection","t","isset","ensureArray","hasOwn","collection","keyOrIndex","_collectionType","length","cloneDeep","Date","flags","exec","copy","constructor","source","lastIndex","map","keys","forEach","k","each","array","callback","thisArg","len","index","apply","eachRight","eachProp","object","key","eachItem","reverseIfArray","pregQuote","str","String","replace","stringOrArrayOf","hasSingleItemOf","arr","itemValue","arguments","removeTrailingWildcards","glob","normalizeNote","note","test","parseInt","joinNotes","notes","current","i","next","join","getNewNotation","newNotation","notation","newN","errMsg","trim","reMATCHER","reVALIDATOR","RegExp","ERR_INVALID","Glob","ins","_inspect","split","absGlob","_","parent","undefined","regexp","isValid","g","indexOf","slice","globA","globB","a","b","notesA","notesB","isNegated","covers","fn","_matchesNote","_coversNote","restrictive","bang","Math","max","notesI","push","isArrayGlob","normalize","aIdxCompare","reANote","last","_covers","_compArrIdx","_compareArrayItemGlobs","wildCountA","wildCountB","globList","sort","compare","_intersect","original","list","concat","_negFirstSort","_negLastSort","negateAll","normalized","ignored","intersections","checkAddIntersection","gA","gB","hasInverted","inter","indexA","duplicate","hasExactNeg","negCoversPos","negCoveredByPos","negCoveredByNeg","posCoversPos","posCoveredByNeg","posCoveredByPos","indexB","JSON","stringify","splice","coversB","coveredByB","keepNeg","keepPos","globsListA","globsListB","union","notCovered","hasExact","negCoversNeg","posCoversNeg","keep","globsA","globsB","_compareUnion","listA","listB","Notation","toRegExp","bIsArr","_idxVal","lastA","lastB","iA","_rx","ERR","SOURCE","DEST","NOTATION","NOTA_OBJ","NO_INDEX","NO_PROP","DEFAULT_OPTS","freeze","strict","preserveIndices","options","_source","_isArray","countNotes","levelNotes","eachNote","_each","level","levelNotation","create","merge","expand","result","has","lastNoteNormalized","lastNote","parentIsArray","parentNotation","get","inspectGet","defaultValue","msg","mode","currentIsLast","nCurrentNote","nNextNote","nextIsArrayNote","insertErrMsg","notationsObject","overwrite","set","notations","inspectRemove","globs","empty","filtered","cloned","firstIsWildcard","shift","globNotation","emptyValue","eType","levels","errGlobIntegrity","insRemove","vType","isValSet","setMode","insGet","originalNotation","levelLen","remove","destination","target","moveTo","rename","copyTo","extract","extrude","_options","byLevel","currentNotation","c","d","name","getter","r","toStringTag","__esModule","ns","bind","n","property","p","s","moduleId","l","modules"],"mappings":"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","file":"notation.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"notation\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"notation\"] = factory();\n\telse\n\t\troot[\"notation\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"lib/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/* eslint consistent-this:0, no-prototype-builtins:0 */\n\nconst setProto = Object.setPrototypeOf;\n\n/**\n *  Error class specific to `Notation`.\n *  @class\n *  @name Notation.Error\n */\nclass NotationError extends Error {\n\n    /**\n     *  Initializes a new `Notation.Error` instance.\n     *  @hideconstructor\n     *  @constructs Notation.Error\n     *  @param {String} message - The error message.\n     */\n    constructor(message = '') {\n        super(message);\n        setProto(this, NotationError.prototype);\n\n        Object.defineProperty(this, 'name', {\n            enumerable: false,\n            writable: false,\n            value: 'NotationError'\n        });\n\n        Object.defineProperty(this, 'message', {\n            enumerable: false,\n            writable: true,\n            value: message\n        });\n\n        /* istanbul ignore else */\n        if (Error.hasOwnProperty('captureStackTrace')) { // V8\n            Error.captureStackTrace(this, NotationError);\n        } else {\n            Object.defineProperty(this, 'stack', {\n                enumerable: false,\n                writable: false,\n                value: (new Error(message)).stack\n            });\n        }\n    }\n\n}\n\nexport { NotationError };\n","\nimport { NotationError } from './core/notation.error';\n\nconst objProto = Object.prototype;\nconst symValueOf = typeof Symbol === 'function'\n    ? Symbol.prototype.valueOf\n    /* istanbul ignore next */\n    : null;\n\n// never use 'g' (global) flag in regexps below\nconst VAR = /^[a-z$_][a-z$_\\d]*$/i;\nconst ARRAY_NOTE = /^\\[(\\d+)\\]$/;\nconst ARRAY_GLOB_NOTE = /^\\[(\\d+|\\*)\\]$/;\nconst OBJECT_BRACKETS = /^\\[(?:'(.*)'|\"(.*)\"|`(.*)`)\\]$/;\nconst WILDCARD = /^(\\[\\*\\]|\\*)$/;\n// matches `*` and `[*]` if outside of quotes.\nconst WILDCARDS = /(\\*|\\[\\*\\])(?=(?:[^\"]|\"[^\"]*\")*$)(?=(?:[^']|'[^']*')*$)/;\n// matches trailing wildcards at the end of a non-negated glob.\n// e.g. `x.y.*[*].*` » $1 = `x.y`, $2 = `.*[*].*`\nconst NON_NEG_WILDCARD_TRAIL = /^(?!!)(.+?)(\\.\\*|\\[\\*\\])+$/;\nconst NEGATE_ALL = /^!(\\*|\\[\\*\\])$/;\n// ending with '.*' or '[*]'\n\nconst _reFlags = /\\w*$/;\n\nconst utils = {\n\n    re: {\n        VAR,\n        ARRAY_NOTE,\n        ARRAY_GLOB_NOTE,\n        OBJECT_BRACKETS,\n        WILDCARD,\n        WILDCARDS,\n        NON_NEG_WILDCARD_TRAIL,\n        NEGATE_ALL\n    },\n\n    type(o) {\n        return objProto.toString.call(o).match(/\\s(\\w+)/i)[1].toLowerCase();\n    },\n\n    isCollection(o) {\n        const t = utils.type(o);\n        return t === 'object' || t === 'array';\n    },\n\n    isset(o) {\n        return o !== undefined && o !== null;\n    },\n\n    ensureArray(o) {\n        if (utils.type(o) === 'array') return o;\n        return o === null || o === undefined ? [] : [o];\n    },\n\n    // simply returning true will get rid of the \"holes\" in the array.\n    // e.g. [0, , 1, , undefined, , , 2, , , null].filter(() => true);\n    // ——» [0, 1, undefined, 2, null]\n\n    // cleanSparseArray(a) {\n    //     return a.filter(() => true);\n    // },\n\n    // added _collectionType for optimization (in loops)\n    hasOwn(collection, keyOrIndex, _collectionType) {\n        if (!collection) return false;\n        const isArr = (_collectionType || utils.type(collection)) === 'array';\n        if (!isArr && typeof keyOrIndex === 'string') {\n            return keyOrIndex && objProto.hasOwnProperty.call(collection, keyOrIndex);\n        }\n        if (typeof keyOrIndex === 'number') {\n            return keyOrIndex >= 0 && keyOrIndex < collection.length;\n        }\n        return false;\n    },\n\n    cloneDeep(collection) {\n        const t = utils.type(collection);\n        switch (t) {\n            case 'date':\n                return new Date(collection.valueOf());\n            case 'regexp': {\n                const flags = _reFlags.exec(collection).toString();\n                const copy = new collection.constructor(collection.source, flags);\n                copy.lastIndex = collection.lastIndex;\n                return copy;\n            }\n            case 'symbol':\n                return symValueOf\n                    ? Object(symValueOf.call(collection))\n                    /* istanbul ignore next */\n                    : collection;\n            case 'array':\n                return collection.map(utils.cloneDeep);\n            case 'object': {\n                const copy = {};\n                // only enumerable string keys\n                Object.keys(collection).forEach(k => {\n                    copy[k] = utils.cloneDeep(collection[k]);\n                });\n                return copy;\n            }\n            // primitives copied over by value\n            // case 'string':\n            // case 'number':\n            // case 'boolean':\n            // case 'null':\n            // case 'undefined':\n            default: // others will be referenced\n                return collection;\n        }\n    },\n\n    // iterates over elements of an array, executing the callback for each\n    // element.\n    each(array, callback, thisArg) {\n        const len = array.length;\n        let index = -1;\n        while (++index < len) {\n            if (callback.apply(thisArg, [array[index], index, array]) === false) return;\n        }\n    },\n\n    eachRight(array, callback, thisArg) {\n        let index = array.length;\n        while (index--) {\n            if (callback.apply(thisArg, [array[index], index, array]) === false) return;\n        }\n    },\n\n    eachProp(object, callback, thisArg) {\n        const keys = Object.keys(object);\n        let index = -1;\n        while (++index < keys.length) {\n            const key = keys[index];\n            if (callback.apply(thisArg, [object[key], key, object]) === false) return;\n        }\n    },\n\n    eachItem(collection, callback, thisArg, reverseIfArray = false) {\n        if (utils.type(collection) === 'array') {\n            // important! we should iterate with eachRight to prevent shifted\n            // indexes when removing items from arrays.\n            return reverseIfArray\n                ? utils.eachRight(collection, callback, thisArg)\n                : utils.each(collection, callback, thisArg);\n        }\n        return utils.eachProp(collection, callback, thisArg);\n    },\n\n    pregQuote(str) {\n        const re = /[.\\\\+*?[^\\]$(){}=!<>|:-]/g;\n        return String(str).replace(re, '\\\\$&');\n    },\n\n    stringOrArrayOf(o, value) {\n        return typeof value === 'string'\n            && (o === value\n                || (utils.type(o) === 'array' && o.length === 1 && o[0] === value)\n            );\n    },\n\n    hasSingleItemOf(arr, itemValue) {\n        return arr.length === 1\n            && (arguments.length === 2 ? arr[0] === itemValue : true);\n    },\n\n    // remove trailing/redundant wildcards if not negated\n    removeTrailingWildcards(glob) {\n        // return glob.replace(/(.+?)(\\.\\*|\\[\\*\\])*$/, '$1');\n        return glob.replace(NON_NEG_WILDCARD_TRAIL, '$1');\n    },\n\n    normalizeNote(note) {\n        if (VAR.test(note)) return note;\n        // check array index notation e.g. `[1]`\n        let m = note.match(ARRAY_NOTE);\n        if (m) return parseInt(m[1], 10);\n        // check object bracket notation e.g. `[\"a-b\"]`\n        m = note.match(OBJECT_BRACKETS);\n        if (m) return (m[1] || m[2] || m[3]);\n        throw new NotationError(`Invalid note: '${note}'`);\n    },\n\n    joinNotes(notes) {\n        const lastIndex = notes.length - 1;\n        return notes.map((current, i) => {\n            if (!current) return '';\n            const next = lastIndex >= i + 1 ? notes[i + 1] : null;\n            const dot = next\n                ? next[0] === '[' ? '' : '.'\n                : '';\n            return current + dot;\n        }).join('');\n    },\n\n    getNewNotation(newNotation, notation) {\n        const errMsg = `Invalid new notation: '${newNotation}'`;\n        // note validations (for newNotation and notation) are already made by\n        // other methods in the flow.\n        let newN;\n        if (typeof newNotation === 'string') {\n            newN = newNotation.trim();\n            if (!newN) throw new NotationError(errMsg);\n            return newN;\n        }\n        if (notation && !utils.isset(newNotation)) return notation;\n        throw new NotationError(errMsg);\n    }\n\n};\n\nexport { utils };\n","/* eslint no-use-before-define:0, consistent-return:0, max-statements:0 */\n\nimport { Notation } from './notation';\nimport { NotationError } from './notation.error';\nimport { utils } from '../utils';\n\n// http://www.linfo.org/wildcard.html\n// http://en.wikipedia.org/wiki/Glob_%28programming%29\n// http://en.wikipedia.org/wiki/Wildcard_character#Computing\n\n// created test @ https://regex101.com/r/U08luj/2\nconst reMATCHER = /(\\[(\\d+|\\*|\".*\"|'.*')\\]|[a-z$_][a-z$_\\d]*|\\*)/gi; // ! negation should be removed first\n// created test @ https://regex101.com/r/mC8unE/3\n// /^!?(\\*|[a-z$_][a-z$_\\d]*|\\[(\\d+|\".*\"|'.*'|`.*`|\\*)\\])(\\[(\\d+|\".*\"|'.*'|`.*`|\\*)\\]|\\.[a-z$_][a-z$_\\d]*|\\.\\*)*$/i\nconst reVALIDATOR = new RegExp(\n    '^'\n    + '!?('                             // optional negation, only in the front\n    + '\\\\*'                             // wildcard star\n    + '|'                               // OR\n    + '[a-z$_][a-z$_\\\\d]*'              // JS variable syntax\n    + '|'                               // OR\n    + '\\\\[(\\\\d+|\\\\*|\".*\"|\\'.*\\')\\\\]'    // array index or wildcard, or object bracket notation\n    + ')'                               // exactly once\n    + '('\n    + '\\\\[(\\\\d+|\\\\*|\".*\"|\\'.*\\')\\\\]'    // followed by same\n    + '|'                               // OR\n    + '\\\\.[a-z$_][a-z$_\\\\d]*'           // dot, then JS variable syntax\n    + '|'                               // OR\n    + '\\\\.\\\\*'                          // dot, then wildcard star\n    + ')*'                              // (both) may repeat any number of times\n    + '$'\n    , 'i'\n);\n\nconst { re } = utils;\nconst ERR_INVALID = 'Invalid glob notation: ';\n\n/**\n *  `Notation.Glob` is a utility for validating, comparing and sorting\n *  dot-notation globs.\n *\n *  You can use {@link http://www.linfo.org/wildcard.html|wildcard} stars `*`\n *  and negate the notation by prepending a bang `!`. A star will include all\n *  the properties at that level and a negated notation will be excluded.\n *  @name Glob\n *  @memberof Notation\n *  @class\n *\n *  @example\n *  // for the following object;\n *  { name: 'John', billing: { account: { id: 1, active: true } } };\n *\n *  'billing.account.*'  // represents value `{ id: 1, active: true }`\n *  'billing.account.id' // represents value `1`\n *  '!billing.account.*' // represents value `{ name: 'John' }`\n *  'name' // represents `'John'`\n *  '*' // represents the whole object\n *\n *  @example\n *  var glob = new Notation.Glob('billing.account.*');\n *  glob.test('billing.account.id'); // true\n */\nclass Glob {\n\n    /**\n     *  Constructs a `Notation.Glob` object with the given glob string.\n     *  @constructs Notation.Glob\n     *  @param {String} glob - Notation string with globs.\n     *\n     *  @throws {NotationError} - If given notation glob is invalid.\n     */\n    constructor(glob) {\n        const ins = Glob._inspect(glob);\n        const notes = Glob.split(ins.absGlob);\n        this._ = {\n            ...ins,\n            notes,\n            // below props will be set at first getter call\n            parent: undefined, // don't set to null\n            regexp: undefined\n        };\n    }\n\n    // --------------------------------\n    // INSTANCE PROPERTIES\n    // --------------------------------\n\n    /**\n     *  Gets the normalized glob notation string.\n     *  @name Notation.Glob#glob\n     *  @type {String}\n     */\n    get glob() {\n        return this._.glob;\n    }\n\n    /**\n     *  Gets the absolute glob notation without the negation prefix `!` and\n     *  redundant trailing wildcards.\n     *  @name Notation.Glob#absGlob\n     *  @type {String}\n     */\n    get absGlob() {\n        return this._.absGlob;\n    }\n\n    /**\n     *  Specifies whether this glob is negated with a `!` prefix.\n     *  @name Notation.Glob#isNegated\n     *  @type {Boolean}\n     */\n    get isNegated() {\n        return this._.isNegated;\n    }\n\n    /**\n     *  Represents this glob in regular expressions.\n     *  Note that the negation prefix (`!`) is ignored, if any.\n     *  @name Notation.Glob#regexp\n     *  @type {RegExp}\n     */\n    get regexp() {\n        // setting on first call instead of in constructor, for performance\n        // optimization.\n        this._.regexp = this._.regexp || Glob.toRegExp(this.absGlob);\n        return this._.regexp;\n    }\n\n    /**\n     *  List of notes (levels) of this glob notation. Note that trailing,\n     *  redundant wildcards are removed from the original glob notation.\n     *  @name Notation.Glob#notes\n     *  @alias Notation.Glob#levels\n     *  @type {Array}\n     */\n    get notes() {\n        return this._.notes;\n    }\n\n    /**\n     *  Alias of `Notation.Glob#notes`.\n     *  @private\n     *  @name Notation.Glob#notes\n     *  @alias Notation.Glob#levels\n     *  @type {Array}\n     */\n    get levels() {\n        return this._.notes;\n    }\n\n    /**\n     *  Gets the first note of this glob notation.\n     *  @name Notation.Glob#first\n     *  @type {String}\n     */\n    get first() {\n        return this.notes[0];\n    }\n\n    /**\n     *  Gets the last note of this glob notation.\n     *  @name Notation.Glob#last\n     *  @type {String}\n     */\n    get last() {\n        return this.notes[this.notes.length - 1];\n    }\n\n    /**\n     *  Gets the parent notation (up to but excluding the last note) from the\n     *  glob notation string. Note that initially, trailing/redundant wildcards\n     *  are removed.\n     *  @name Notation.Glob#parent\n     *  @type {String}\n     *\n     *  @example\n     *  const glob = Notation.Glob.create;\n     *  glob('first.second.*').parent;   // \"first.second\"\n     *  glob('*.x.*').parent;            // \"*\" (\"*.x.*\" normalizes to \"*.x\")\n     *  glob('*').parent;                // null (no parent)\n     */\n    get parent() {\n        // setting on first call instead of in constructor, for performance\n        // optimization.\n        if (this._.parent === undefined) {\n            this._.parent = this.notes.length > 1\n                ? this.absGlob.slice(0, -this.last.length).replace(/\\.$/, '')\n                : null;\n        }\n        return this._.parent;\n    }\n\n    // --------------------------------\n    // INSTANCE METHODS\n    // --------------------------------\n\n    /**\n     *  Checks whether the given notation value matches the source notation\n     *  glob.\n     *  @name Notation.Glob#test\n     *  @function\n     *  @param {String} notation - The notation string to be tested. Cannot have\n     *  any globs.\n     *  @returns {Boolean} -\n     *  @throws {NotationError} - If given `notation` is not valid or contains\n     *  any globs.\n     *\n     *  @example\n     *  const glob = new Notation.Glob('!prop.*.name');\n     *  glob.test(\"prop.account.name\"); // true\n     */\n    test(notation) {\n        if (!Notation.isValid(notation)) {\n            throw new NotationError(`Invalid notation: '${notation}'`);\n        }\n        // return this.regexp.test(notation);\n        return Glob._covers(this, notation);\n    }\n\n    /**\n     *  Specifies whether this glob notation can represent (or cover) the given\n     *  glob notation. Note that negation prefix is ignored, if any.\n     *  @name Notation.Glob#covers\n     *  @function\n     *\n     *  @param {String|Array|Glob} glob  Glob notation string, glob\n     *  notes array or a `Notation.Glob` instance.\n     *  @returns {Boolean} -\n     *\n     *  @example\n     *  const glob = Notation.Glob.create;\n     *  glob('*.y').covers('x.y')      // true\n     *  glob('x[*].y').covers('x[*]')  // false\n     */\n    covers(glob) {\n        return Glob._covers(this, glob);\n    }\n\n    /**\n     *  Gets the intersection of this and the given glob notations. When\n     *  restrictive, if any one of them is negated, the outcome is negated.\n     *  Otherwise, only if both of them are negated, the outcome is negated.\n     *  @name Notation.Glob#intersect\n     *  @function\n     *\n     *  @param {String} glob - Second glob to be used.\n     *  @param {Boolean} [restrictive=false] - Whether the intersection should\n     *  be negated when one of the globs is negated.\n     *  @returns {String} - Intersection notation if any; otherwise `null`.\n     *\n     *  @example\n     *  const glob = Notation.Glob.create;\n     *  glob('x.*').intersect('!*.y')         // 'x.y'\n     *  glob('x.*').intersect('!*.y', true)   // '!x.y'\n     */\n    intersect(glob, restrictive = false) {\n        return Glob._intersect(this.glob, glob, restrictive);\n    }\n\n    // --------------------------------\n    // STATIC MEMBERS\n    // --------------------------------\n\n    /**\n     *  Basically constructs a new `Notation.Glob` instance\n     *  with the given glob string.\n     *  @name Notation.Glob.create\n     *  @function\n     *\n     *  @param {String} glob - The source notation glob.\n     *  @returns {Glob} -\n     *\n     *  @example\n     *  const glob = Notation.Glob.create(strGlob);\n     *  // equivalent to:\n     *  const glob = new Notation.Glob(strGlob);\n     */\n    static create(glob) {\n        return new Glob(glob);\n    }\n\n    // Created test at: https://regex101.com/r/tJ7yI9/4\n    /**\n     *  Validates the given notation glob.\n     *  @name Notation.Glob.isValid\n     *  @function\n     *\n     *  @param {String} glob - Notation glob to be validated.\n     *  @returns {Boolean} -\n     */\n    static isValid(glob) {\n        return typeof glob === 'string' && reVALIDATOR.test(glob);\n    }\n\n    /**\n     *  Specifies whether the given glob notation includes any valid wildcards\n     *  (`*`) or negation bang prefix (`!`).\n     *  @name Notation.Glob.hasMagic\n     *  @function\n     *\n     *  @param {String} glob - Glob notation to be checked.\n     *  @returns {Boolean} -\n     */\n    static hasMagic(glob) {\n        return Glob.isValid(glob) && (re.WILDCARDS.test(glob) || glob[0] === '!');\n    }\n\n    /**\n     *  Gets a regular expressions instance from the given glob notation.\n     *  Note that the bang `!` prefix will be ignored if the given glob is negated.\n     *  @name Notation.Glob.toRegExp\n     *  @function\n     *\n     *  @param {String} glob - Glob notation to be converted.\n     *\n     *  @returns {RegExp} - A `RegExp` instance from the glob.\n     *\n     *  @throws {NotationError} - If given notation glob is invalid.\n     */\n    static toRegExp(glob) {\n        if (!Glob.isValid(glob)) {\n            throw new NotationError(`${ERR_INVALID} '${glob}'`);\n        }\n\n        let g = glob.indexOf('!') === 0 ? glob.slice(1) : glob;\n        g = utils.pregQuote(g)\n            // `[*]` always represents array index e.g. `[1]`. so we'd replace\n            // `\\[\\*\\]` with `\\[\\d+\\]` but we should also watch for quotes: e.g.\n            // `[\"x[*]y\"]`\n            .replace(/\\\\\\[\\\\\\*\\\\\\](?=(?:[^\"]|\"[^\"]*\")*$)(?=(?:[^']|'[^']*')*$)/g, '\\\\[\\\\d+\\\\]')\n            // `*` within quotes (e.g. ['*']) is non-wildcard, just a regular star char.\n            // `*` outside of quotes is always JS variable syntax e.g. `prop.*`\n            .replace(/\\\\\\*(?=(?:[^\"]|\"[^\"]*\")*$)(?=(?:[^']|'[^']*')*$)/g, '[a-z$_][a-z$_\\\\d]*')\n            .replace(/\\\\\\?/g, '.');\n        return new RegExp('^' + g + '(?:[\\\\[\\\\.].+|$)', 'i');\n        // it should either end ($) or continue with a dot or bracket. So for\n        // example, `company.*` will produce `/^company\\.[a-z$_][a-z$_\\\\d]*(?:[\\\\[|\\\\.].+|$)/`\n        // which will match both `company.name` and `company.address.street` but\n        // will not match `some.company.name`. Also `!password` will not match\n        // `!password_reset`.\n    }\n\n    /**\n     *  Specifies whether first glob notation can represent (or cover) the\n     *  second.\n     *  @name Notation.Glob._covers\n     *  @function\n     *  @private\n     *\n     *  @param {String|Object|Glob} globA  Source glob notation string\n     *  or inspection result object or `Notation.Glob` instance.\n     *  @param {String|Object|Glob} globB  Glob notation string or\n     *  inspection result object or `Notation.Glob` instance.\n     *  @param {Boolean} [match=false]  Check whether notes match instead of\n     *  `globA` covers `globB`.\n     *  @returns {Boolean} -\n     *\n     *  @example\n     *  const { covers } = Notation.Glob;\n     *  covers('*.y', 'x.y')        // true\n     *  covers('x.y', '*.y')        // false\n     *  covers('x.y', '*.y', true)  // true\n     *  covers('x[*].y', 'x[*]')    // false\n     */\n    static _covers(globA, globB, match = false) {\n        const a = typeof globA === 'string'\n            ? new Glob(globA)\n            : globA; // assume (globA instanceof Notation.Glob || utils.type(globA) === 'object')\n\n        const b = typeof globB === 'string'\n            ? new Glob(globB)\n            : globB;\n\n        const notesA = a.notes || Glob.split(a.absGlob);\n        const notesB = b.notes || Glob.split(b.absGlob);\n\n        if (!match) {\n            // !x.*.* does not cover !x.* or x.* bec. !x.*.* ≠ x.* ≠ x\n            // x.*.* covers x.* bec. x.*.* = x.* = x\n            if (a.isNegated && notesA.length > notesB.length) return false;\n        }\n\n        let covers = true;\n        const fn = match ? _matchesNote : _coversNote;\n        for (let i = 0; i < notesA.length; i++) {\n            if (!fn(notesA[i], notesB[i])) {\n                covers = false;\n                break;\n            }\n        }\n        return covers;\n    }\n\n    /**\n     *  Gets the intersection notation of two glob notations. When restrictive,\n     *  if any one of them is negated, the outcome is negated. Otherwise, only\n     *  if both of them are negated, the outcome is negated.\n     *  @name Notation.Glob._intersect\n     *  @function\n     *  @private\n     *\n     *  @param {String} globA - First glob to be used.\n     *  @param {String} globB - Second glob to be used.\n     *  @param {Boolean} [restrictive=false] - Whether the intersection should\n     *  be negated when one of the globs is negated.\n     *  @returns {String} - Intersection notation if any; otherwise `null`.\n     *  @example\n     *  _intersect('!*.y', 'x.*', false)     // 'x.y'\n     *  _intersect('!*.y', 'x.*', true)      // '!x.y'\n     */\n    static _intersect(globA, globB, restrictive = false) {\n        // const bang = restrictive\n        //     ? (globA[0] === '!' || globB[0] === '!' ? '!' : '')\n        //     : (globA[0] === '!' && globB[0] === '!' ? '!' : '');\n\n        const notesA = Glob.split(globA, true);\n        const notesB = Glob.split(globB, true);\n\n        let bang;\n        if (restrictive) {\n            bang = globA[0] === '!' || globB[0] === '!' ? '!' : '';\n        } else {\n            if (globA[0] === '!' && globB[0] === '!') {\n                bang = '!';\n            } else {\n                bang = ((notesA.length > notesB.length && globA[0] === '!')\n                        || (notesB.length > notesA.length && globB[0] === '!'))\n                    ? '!'\n                    : '';\n            }\n        }\n\n        const len = Math.max(notesA.length, notesB.length);\n        let notesI = [];\n        let a, b;\n        //   x.*  ∩  *.y   »  x.y\n        // x.*.*  ∩  *.y   »  x.y.*\n        // x.*.z  ∩  *.y   »  x.y.z\n        //   x.y  ∩  *.b   »  (n/a)\n        //   x.y  ∩  a.*   »  (n/a)\n        for (let i = 0; i < len; i++) {\n            a = notesA[i];\n            b = notesB[i];\n            if (a === b) {\n                notesI.push(a);\n            } else if (a && re.WILDCARD.test(a)) {\n                if (!b) {\n                    notesI.push(a);\n                } else {\n                    notesI.push(b);\n                }\n            } else if (b && re.WILDCARD.test(b)) {\n                if (!a) {\n                    notesI.push(b);\n                } else {\n                    notesI.push(a);\n                }\n            } else if (a && !b) {\n                notesI.push(a);\n            } else if (!a && b) {\n                notesI.push(b);\n            } else { // if (a !== b) {\n                notesI = [];\n                break;\n            }\n        }\n\n        if (notesI.length > 0) return bang + utils.joinNotes(notesI);\n        return null;\n    }\n\n    /**\n     *  Undocumented.\n     *  @name Notation.Glob._inspect\n     *  @function\n     *  @private\n     *\n     *  @param {String} glob -\n     *  @returns {Object} -\n     */\n    static _inspect(glob) {\n        let g = glob.trim();\n        if (!Glob.isValid(g)) {\n            throw new NotationError(`${ERR_INVALID} '${glob}'`);\n        }\n        const isNegated = g[0] === '!';\n        // trailing wildcards are only redundant if not negated\n        if (!isNegated) g = utils.removeTrailingWildcards(g);\n        const absGlob = isNegated ? g.slice(1) : g;\n        return {\n            glob: g,\n            absGlob,\n            isNegated,\n            // e.g. [*] or [1] are array globs. [\"1\"] is not.\n            isArrayGlob: (/^\\[[^'\"]/).test(absGlob)\n        };\n    }\n\n    /**\n     *  Splits the given glob notation string into its notes (levels). Note that\n     *  this will exclude the `!` negation prefix, if it exists.\n     *  @name Notation.Glob.split\n     *  @function\n     *\n     *  @param {String} glob  Glob notation string to be splitted.\n     *  @param {String} [normalize=false]  Whether to remove trailing, redundant\n     *  wildcards.\n     *  @returns {Array} - A string array of glob notes (levels).\n     *  @throws {NotationError} - If given glob notation is invalid.\n     *\n     *  @example\n     *  Notation.Glob.split('*.list[2].prop')  // ['*', 'list', '[2]', 'prop']\n     *  // you can get the same result from the .notes property of a Notation.Glob instance.\n     */\n    static split(glob, normalize = false) {\n        if (!Glob.isValid(glob)) {\n            throw new NotationError(`${ERR_INVALID} '${glob}'`);\n        }\n        const neg = glob[0] === '!';\n        // trailing wildcards are redundant only when not negated\n        const g = !neg && normalize ? utils.removeTrailingWildcards(glob) : glob;\n        return g.replace(/^!/, '').match(reMATCHER);\n    }\n\n    /**\n     *  Compares two given notation globs and returns an integer value as a\n     *  result. This is generally used to sort glob arrays. Loose globs (with\n     *  stars especially closer to beginning of the glob string) and globs\n     *  representing the parent/root of the compared property glob come first.\n     *  Verbose/detailed/exact globs come last. (`* < *.abc < abc`).\n     *\n     *  For instance; `store.address` comes before `store.address.street`. So\n     *  this works both for `*, store.address.street, !store.address` and `*,\n     *  store.address, !store.address.street`. For cases such as `prop.id` vs\n     *  `!prop.id` which represent the same property; the negated glob comes\n     *  last.\n     *  @name Notation.Glob.compare\n     *  @function\n     *\n     *  @param {String} globA - First notation glob to be compared.\n     *  @param {String} globB - Second notation glob to be compared.\n     *\n     *  @returns {Number} - Returns `-1` if `globA` comes first, `1` if `globB`\n     *  comes first and `0` if equivalent priority.\n     *\n     *  @throws {NotationError} - If either `globA` or `globB` is invalid glob\n     *  notation.\n     *\n     *  @example\n     *  const { compare } = Notation.Glob;\n     *  compare('*', 'info.user')               // -1\n     *  compare('*', '[*]')                     // 0\n     *  compare('info.*.name', 'info.user')     // 1\n     */\n    static compare(globA, globB) {\n        // trivial case, both are exactly the same!\n        // or both are wildcard e.g. `*` or `[*]`\n        if (globA === globB || (re.WILDCARD.test(globA) && re.WILDCARD.test(globB))) return 0;\n\n        const a = new Glob(globA);\n        const b = new Glob(globB);\n\n        // Check depth (number of levels)\n        if (a.notes.length === b.notes.length) {\n            // check and compare if these are globs that represent items in the\n            // \"same\" array. if not, this will return 0.\n            const aIdxCompare = _compareArrayItemGlobs(a, b);\n            // we'll only continue comparing if 0 is returned\n            if (aIdxCompare !== 0) return aIdxCompare;\n\n            // count wildcards\n            const wildCountA = (a.absGlob.match(re.WILDCARDS) || []).length;\n            const wildCountB = (b.absGlob.match(re.WILDCARDS) || []).length;\n            if (wildCountA === wildCountB) {\n                // check for negation\n                if (!a.isNegated && b.isNegated) return -1;\n                if (a.isNegated && !b.isNegated) return 1;\n                // both are negated or neither are, return alphabetical\n                return a.absGlob < b.absGlob ? -1 : (a.absGlob > b.absGlob ? 1 : 0);\n            }\n            return wildCountA > wildCountB ? -1 : 1;\n        }\n\n        return a.notes.length < b.notes.length ? -1 : 1;\n    }\n\n    /**\n     *  Sorts the notation globs in the given array by their priorities. Loose\n     *  globs (with stars especially closer to beginning of the glob string);\n     *  globs representing the parent/root of the compared property glob come\n     *  first. Verbose/detailed/exact globs come last. (`* < *.y < x.y`).\n     *\n     *  For instance; `store.address` comes before `store.address.street`. For\n     *  cases such as `prop.id` vs `!prop.id` which represent the same property;\n     *  the negated glob wins (comes last).\n     *  @name Notation.Glob.sort\n     *  @function\n     *\n     *  @param {Array} globList - The notation globs array to be sorted. The\n     *  passed array reference is modified.\n     *  @returns {Array} - Logically sorted globs array.\n     *\n     *  @example\n     *  Notation.Glob.sort(['!prop.*.name', 'prop.*', 'prop.id']) // ['prop.*', 'prop.id', '!prop.*.name'];\n     */\n    static sort(globList) {\n        return globList.sort(Glob.compare);\n    }\n\n    /**\n     *  Normalizes the given notation globs array by removing duplicate or\n     *  redundant items, eliminating extra verbosity (also with intersection\n     *  globs) and returns a priority-sorted globs array.\n     *\n     *  <ul>\n     *  <li>If any exact duplicates found, all except first is removed.\n     *  <br />example: `['car', 'dog', 'car']` normalizes to `['car', 'dog']`.</li>\n     *  <li>If both normal and negated versions of a glob are found, negated wins.\n     *  <br />example: `['*', 'id', '!id']` normalizes to `['*', '!id']`.</li>\n     *  <li>If a glob is covered by another, it's removed.\n     *  <br />example: `['car.*', 'car.model']` normalizes to `['car']`.</li>\n     *  <li>If a negated glob is covered by another glob, it's kept.\n     *  <br />example: `['*', 'car', '!car.model']` normalizes as is.</li>\n     *  <li>If a negated glob is not covered by another or it does not cover any other;\n     *  then we check for for intersection glob. If found, adds them to list;\n     *  removes the original negated.\n     *  <br />example: `['car.*', '!*.model']` normalizes as to `['car', '!car.model']`.</li>\n     *  <li>In restrictive mode; if a glob is covered by another negated glob, it's removed.\n     *  Otherwise, it's kept.\n     *  <br />example: `['*', '!car.*', 'car.model']` normalizes to `['*', '!car']` if restrictive.</li>\n     *  </ul>\n     *  @name Notation.Glob.normalize\n     *  @function\n     *\n     *  @param {Array} globList - Notation globs array to be normalized.\n     *  @param {Boolean} [restrictive=false] - Whether negated items strictly\n     *  remove every match. Note that, regardless of this option, if any item has an\n     *  exact negated version; non-negated is always removed.\n     *  @returns {Array} -\n     *\n     *  @throws {NotationError} - If any item in globs list is invalid.\n     *\n     *  @example\n     *  const { normalize } = Notation.Glob;\n     *  normalize(['*', '!id', 'name', '!car.model', 'car.*', 'id', 'name']); // ['*', '!id', '!car.model']\n     *  normalize(['!*.id', 'user.*', 'company']); // ['company', 'user', '!company.id', '!user.id']\n     *  normalize(['*', 'car.model', '!car.*']); // [\"*\", \"!car.*\", \"car.model\"]\n     *  // restrictive normalize:\n     *  normalize(['*', 'car.model', '!car.*'], true); // [\"*\", \"!car.*\"]\n     */\n    static normalize(globList, restrictive = false) {\n        const { _inspect, _covers, _intersect } = Glob;\n\n        const original = utils.ensureArray(globList);\n        if (original.length === 0) return [];\n\n        const list = original\n            // prevent mutation\n            .concat()\n            // move negated globs to top so that we inspect non-negated globs\n            // against others first. when complete, we'll sort with our\n            // .compare() function.\n            .sort(restrictive ? _negFirstSort : _negLastSort)\n            // turning string array into inspect-obj array, so that we'll not\n            // run _inspect multiple times in the inner loop. this also\n            // pre-validates each glob.\n            .map(_inspect);\n\n        // early return if we have a single item\n        if (list.length === 1) {\n            const g = list[0];\n            // single negated item is redundant\n            if (g.isNegated) return [];\n            // return normalized\n            return [g.glob];\n        }\n\n        // flag to return an empty array (in restrictive mode), if true.\n        let negateAll = false;\n\n        // we'll push keepers in this array\n        let normalized = [];\n        // we'll need to remember excluded globs, so that we can move to next\n        // item early.\n        const ignored = {};\n\n        // storage to keep intersections.\n        // using an object to prevent duplicates.\n        let intersections = {};\n\n        function checkAddIntersection(gA, gB) {\n            const inter = _intersect(gA, gB, restrictive);\n            if (!inter) return;\n            // if the intersection result has an inverted version in the\n            // original list, don't add this.\n            const hasInverted = restrictive ? false : original.indexOf(_invert(inter)) >= 0;\n            // also if intersection result is in the current list, don't add it.\n            if (list.indexOf(inter) >= 0 || hasInverted) return;\n            intersections[inter] = inter;\n        }\n\n        // iterate each glob by comparing it to remaining globs.\n        utils.eachRight(list, (a, indexA) => {\n\n            // if `strict` is enabled, return empty if a negate-all is found\n            // (which itself is also redundant if single): '!*' or '![*]'\n            if (re.NEGATE_ALL.test(a.glob)) {\n                negateAll = true;\n                if (restrictive) return false;\n            }\n\n            // flags\n            let duplicate = false;\n            let hasExactNeg = false;\n            // flags for negated\n            let negCoversPos = false;\n            let negCoveredByPos = false;\n            let negCoveredByNeg = false;\n            // flags for non-negated (positive)\n            let posCoversPos = false;\n            let posCoveredByNeg = false;\n            let posCoveredByPos = false;\n\n            utils.eachRight(list, (b, indexB) => {\n                // don't inspect glob with itself\n                if (indexA === indexB) return; // move to next\n                // console.log(indexA, a.glob, 'vs', b.glob);\n\n                if (a.isArrayGlob !== b.isArrayGlob) {\n                    throw new NotationError(`Integrity failed. Cannot have both object and array notations for root level: ${JSON.stringify(original)}`);\n                }\n\n                // remove if duplicate\n                if (a.glob === b.glob) {\n                    list.splice(indexA, 1);\n                    duplicate = true;\n                    return false; // break out\n                }\n\n                // remove if positive has an exact negated (negated wins when\n                // normalized) e.g. ['*', 'a', '!a'] => ['*', '!a']\n                if (!a.isNegated && _isReverseOf(a, b)) {\n                    // list.splice(indexA, 1);\n                    ignored[a.glob] = true;\n                    hasExactNeg = true;\n                    return false; // break out\n                }\n\n                // if already excluded b, go on to next\n                if (ignored[b.glob]) return; // next\n\n                const coversB = _covers(a, b);\n                const coveredByB = coversB ? false : _covers(b, a);\n                if (a.isNegated) {\n                    if (b.isNegated) {\n                        // if negated (a) covered by any other negated (b); remove (a)!\n                        if (coveredByB) {\n                            negCoveredByNeg = true;\n                            // list.splice(indexA, 1);\n                            ignored[a.glob] = true;\n                            return false; // break out\n                        }\n                    } else {\n                        /* istanbul ignore if */\n                        if (coversB) negCoversPos = true;\n                        if (coveredByB) negCoveredByPos = true;\n                        // try intersection if none covers the other and only\n                        // one of them is negated.\n                        if (!coversB && !coveredByB) {\n                            checkAddIntersection(a.glob, b.glob);\n                        }\n                    }\n                } else {\n                    if (b.isNegated) {\n                        // if positive (a) covered by any negated (b); remove (a)!\n                        if (coveredByB) {\n                            posCoveredByNeg = true;\n                            if (restrictive) {\n                                // list.splice(indexA, 1);\n                                ignored[a.glob] = true;\n                                return false; // break out\n                            }\n                            return; // next\n                        }\n                        // try intersection if none covers the other and only\n                        // one of them is negated.\n                        if (!coversB && !coveredByB) {\n                            checkAddIntersection(a.glob, b.glob);\n                        }\n                    } else {\n                        if (coversB) posCoversPos = coversB;\n                        // if positive (a) covered by any other positive (b); remove (a)!\n                        if (coveredByB) {\n                            posCoveredByPos = true;\n                            if (restrictive) {\n                                // list.splice(indexA, 1);\n                                return false; // break out\n                            }\n                        }\n                    }\n                }\n\n            });\n\n            // const keepNeg = (negCoversPos || negCoveredByPos) && !negCoveredByNeg;\n            const keepNeg = restrictive\n                ? (negCoversPos || negCoveredByPos) && negCoveredByNeg === false\n                : negCoveredByPos && negCoveredByNeg === false;\n            const keepPos = restrictive\n                ? (posCoversPos || posCoveredByPos === false) && posCoveredByNeg === false\n                : posCoveredByNeg || posCoveredByPos === false;\n            const keep = duplicate === false\n                && hasExactNeg === false\n                && (a.isNegated ? keepNeg : keepPos);\n\n            if (keep) {\n                normalized.push(a.glob);\n            } else {\n                // this is excluded from final (normalized) list, so mark as\n                // ignored (don't remove from \"list\" for now)\n                ignored[a.glob] = true;\n            }\n        });\n\n        if (restrictive && negateAll) return [];\n\n        intersections = Object.keys(intersections);\n        if (intersections.length > 0) {\n            // merge normalized list with intersections if any\n            normalized = normalized.concat(intersections);\n            // we have new (intersection) items, so re-normalize\n            return Glob.normalize(normalized, restrictive);\n        }\n\n        return Glob.sort(normalized);\n    }\n\n    /**\n     *  Undocumented. See `.union()`\n     *  @name Notation.Glob._compareUnion\n     *  @function\n     *  @private\n     *\n     *  @param {Array} globsListA -\n     *  @param {Array} globsListB -\n     *  @param {Boolean} restrictive -\n     *  @param {Array} union -\n     *  @returns {Array} -\n     */\n    static _compareUnion(globsListA, globsListB, restrictive, union = []) {\n        const { _covers } = Glob;\n\n        const { _inspect, _intersect } = Glob;\n\n        utils.eachRight(globsListA, globA => {\n            if (union.indexOf(globA) >= 0) return; // next\n\n            const a = _inspect(globA);\n\n            // if wildcard only, add...\n            if (re.WILDCARD.test(a.absGlob)) {\n                union.push(a.glob); // push normalized glob\n                return; // next\n            }\n\n            let notCovered = false;\n            let hasExact = false;\n            let negCoversNeg = false;\n            let posCoversNeg = false;\n            let posCoversPos = false;\n            let negCoversPos = false;\n\n            const intersections = [];\n\n            utils.eachRight(globsListB, globB => {\n\n                // keep if has exact in the other\n                if (globA === globB) hasExact = true;\n\n                const b = _inspect(globB);\n\n                // keep negated if:\n                //    1) any negated covers it\n                //    2) no positive covers it\n                // keep positive if:\n                //    1) no positive covers it OR any negated covers it\n\n                notCovered = !_covers(b, a);\n                if (notCovered) {\n                    if (a.isNegated && b.isNegated) {\n                        const inter = _intersect(a.glob, b.glob, restrictive);\n                        if (inter && union.indexOf(inter) === -1) intersections.push(inter);\n                    }\n                    return; // next\n                }\n\n                if (a.isNegated) {\n                    if (b.isNegated) {\n                        negCoversNeg = !hasExact;\n                    } else {\n                        posCoversNeg = true; // set flag\n                    }\n                } else {\n                    if (!b.isNegated) {\n                        posCoversPos = !hasExact;\n                    } else {\n                        negCoversPos = true; // set flag\n                    }\n                }\n\n            });\n\n\n            const keep = a.isNegated\n                ? (!posCoversNeg || negCoversNeg)\n                : (!posCoversPos || negCoversPos);\n\n            if (hasExact || keep || (notCovered && !a.isNegated)) {\n                union.push(a.glob); // push normalized glob\n                return;\n            }\n\n            if (a.isNegated && posCoversNeg && !negCoversNeg && intersections.length > 0) {\n                union = union.concat(intersections);\n            }\n\n        });\n\n        return union;\n    }\n\n    /**\n     *  Gets the union from the given couple of glob arrays and returns a new\n     *  array of globs.\n     *  <ul>\n     *  <li>If the exact same element is found in both\n     *  arrays, one of them is removed to prevent duplicates.\n     *  <br />example: `['!id', 'name'] ∪ ['!id']` unites to `['!id', 'name']`</li>\n     *  <li>If any non-negated item is covered by a glob in the same\n     *  or other array, the redundant item is removed.\n     *  <br />example: `['*', 'name'] ∪ ['email']` unites to `['*']`</li>\n     *  <li>If one of the arrays contains a negated equivalent of an\n     *  item in the other array, the negated item is removed.\n     *  <br />example: `['!id'] ∪ ['id']` unites to `['id']`</li>\n     *  <li>If any item covers/matches a negated item in the other array,\n     *  the negated item is removed.\n     *  <br />example #1: `['!user.id'] ∪ ['user.*']` unites to `['user']`\n     *  <br />example #2: `['*'] ∪ ['!password']` unites to `['*']`\n     *  </li>\n     *  </ul>\n     *  @name Notation.Glob.union\n     *  @function\n     *\n     *  @param {Array} globsA - First array of glob strings.\n     *  @param {Array} globsB - Second array of glob strings.\n     *  @param {Boolean} [restrictive=false] - Whether negated items in each of\n     *  the lists, strictly remove every match in themselves (not the cross\n     *  list). This option is used when pre-normalizing each glob list and\n     *  normalizing the final union list.\n     *\n     *  @returns {Array} -\n     *\n     *  @example\n     *  const a = ['user.*', '!user.email', 'car.model', '!*.id'];\n     *  const b = ['!*.date', 'user.email', 'car', '*.age'];\n     *  const { union } = Notation.Glob;\n     *  union(a, b)     // ['car', 'user', '*.age', '!car.date', '!user.id']\n     */\n    static union(globsA, globsB, restrictive) {\n        const { normalize, _compareUnion } = Glob;\n\n        const listA = normalize(globsA, restrictive);\n        const listB = normalize(globsB, restrictive);\n\n        if (listA.length === 0) return listB;\n        if (listB.length === 0) return listA;\n\n        // TODO: below should be optimized\n        let union = _compareUnion(listA, listB, restrictive);\n        union = _compareUnion(listB, listA, restrictive, union);\n        return normalize(union, restrictive);\n    }\n\n}\n\n// --------------------------------\n// HELPERS\n// --------------------------------\n\n// used by static _covers\nfunction _coversNote(a, b) {\n    if (!a || !b) return false; // glob e.g.: [2] does not cover [2][1]\n    const bIsArr = re.ARRAY_GLOB_NOTE.test(b);\n    // obj-wildcard a will cover b if not array\n    if (a === '*') return !bIsArr;\n    // arr-wildcard a will cover b if array\n    if (a === '[*]') return bIsArr;\n    // seems, a is not wildcard so,\n    // if b is wildcard (obj or arr) won't be covered\n    if (re.WILDCARD.test(b)) return false;\n    // normalize both and check for equality\n    // e.g. x.y and x['y'] are the same\n    return utils.normalizeNote(a) === utils.normalizeNote(b);\n}\n// function _coversNote(a, b) {\n//     if (!a || !b) return false; // glob e.g.: [2] does not cover [2][1]\n//     a = utils.normalizeNote(a, true);\n//     b = utils.normalizeNote(b, true);\n//     if (a === b) return true;\n//     const bIsArr = re.ARRAY_GLOB_NOTE.test(b);\n//     return (a === '*' && !bIsArr) || (a === '[*]' && bIsArr);\n// }\n// used by static _covers\nfunction _matchesNote(a, b) {\n    if (!a || !b) return true; // glob e.g.: [2][1] matches [2] and vice-versa.\n    return _coversNote(a, b) || _coversNote(b, a);\n}\n\n// used by _compareArrayItemGlobs() for getting a numeric index from array note.\n// we'll use these indexes to sort higher to lower, as removing order; to\n// prevent shifted indexes.\nfunction _idxVal(note) {\n    // we return -1 for wildcard bec. we need it to come last\n\n    // below will never execute when called from _compareArrayItemGlobs\n    /* istanbul ignore next */\n    // if (note === '[*]') return -1;\n\n    // e.g. '[2]' » 2\n    return parseInt(note.replace(/[[\\]]/, ''), 10);\n}\n\nfunction _compArrIdx(lastA, lastB) {\n    const iA = _idxVal(lastA);\n    const iB = _idxVal(lastB);\n\n    // below will never execute when called from _compareArrayItemGlobs\n    /* istanbul ignore next */\n    // if (iA === iB) return 0;\n\n    return iA > iB ? -1 : 1;\n}\n\n// when we remove items from an array (via e.g. filtering), we first need to\n// remove the item with the greater index so indexes of other items (that are to\n// be removed from the same array) do not shift. so below is for comparing 2\n// globs if they represent 2 items from the same array.\n\n// example items from same array: ![*][2] ![0][*] ![0][1] ![0][3]\n// should be sorted as ![0][3] ![*][2] ![0][1] ![0][*]\nfunction _compareArrayItemGlobs(a, b) {\n    const reANote = re.ARRAY_GLOB_NOTE;\n    // both should be negated\n    if (!a.isNegated\n            || !b.isNegated\n            // should be same length (since we're comparing for items in same\n            // array)\n            || a.notes.length !== b.notes.length\n            // last notes should be array brackets\n            || !reANote.test(a.last)\n            || !reANote.test(b.last)\n            // last notes should be different to compare\n            || a.last === b.last\n    ) return 0;\n\n    // negated !..[*] should come last\n    if (a.last === '[*]') return 1; // b is first\n    if (b.last === '[*]') return -1; // a is first\n\n    if (a.parent && b.parent) {\n        const { _covers } = Glob;\n        if (_covers(a.parent, b.parent, true)) {\n            return _compArrIdx(a.last, b.last);\n        }\n        return 0;\n    }\n    return _compArrIdx(a.last, b.last);\n}\n\n// x vs !x.*.*      » false\n// x vs !x[*]       » true\n// x[*] vs !x       » true\n// x[*] vs !x[*]    » false\n// x.* vs !x.*      » false\nfunction _isReverseOf(a, b) {\n    return a.isNegated !== b.isNegated\n        && a.absGlob === b.absGlob;\n}\n\nfunction _invert(glob) {\n    return glob[0] === '!' ? glob.slice(1) : '!' + glob;\n}\n\nconst _rx = /^\\s*!/;\nfunction _negFirstSort(a, b) {\n    return _rx.test(a) ? -1 : (_rx.test(b) ? 1 : 0);\n}\nfunction _negLastSort(a, b) {\n    return _rx.test(a) ? 1 : (_rx.test(b) ? -1 : 0);\n}\n\n// --------------------------------\n// EXPORT\n// --------------------------------\n\nexport { Glob };\n","/* eslint no-use-before-define:0, consistent-return:0, max-statements:0, max-len:0 */\n\nimport { Glob } from './notation.glob';\nimport { NotationError } from './notation.error';\nimport { utils } from '../utils';\n\nconst ERR = {\n    SOURCE: 'Invalid source. Expected a data object or array.',\n    DEST: 'Invalid destination. Expected a data object or array.',\n    NOTATION: 'Invalid notation: ',\n    NOTA_OBJ: 'Invalid notations object. ',\n    NO_INDEX: 'Implied index does not exist: ',\n    NO_PROP: 'Implied property does not exist: '\n};\n\n// created test @ https://regex101.com/r/vLE16M/2\nconst reMATCHER = /(\\[(\\d+|\".*\"|'.*'|`.*`)\\]|[a-z$_][a-z$_\\d]*)/gi;\n// created test @ https://regex101.com/r/fL3PJt/1/\n// /^([a-z$_][a-z$_\\d]*|\\[(\\d+|\".*\"|'.*'|`.*`)\\])(\\[(\\d+|\".*\"|'.*'|`.*`)\\]|(\\.[a-z$_][a-z$_\\d]*))*$/i\nconst reVALIDATOR = new RegExp(\n    '^('\n    + '[a-z$_][a-z$_\\\\d]*'          // JS variable syntax\n    + '|'                           // OR\n    + '\\\\[(\\\\d+|\".*\"|\\'.*\\')\\\\]'    // array index or object bracket notation\n    + ')'                           // exactly once\n    + '('\n    + '\\\\[(\\\\d+|\".*\"|\\'.*\\')\\\\]'    // followed by same\n    + '|'                           // OR\n    + '\\\\.[a-z$_][a-z$_\\\\d]*'       // dot, then JS variable syntax\n    + ')*'                          // (both) may repeat any number of times\n    + '$'\n    , 'i'\n);\n\nconst DEFAULT_OPTS = Object.freeze({\n    strict: false,\n    preserveIndices: false\n});\n\n/**\n *  Notation.js for Node and Browser.\n *\n *  Like in most programming languages, JavaScript makes use of dot-notation to\n *  access the value of a member of an object (or class). `Notation` class\n *  provides various methods for modifying / processing the contents of the\n *  given object; by parsing object notation strings or globs.\n *\n *  Note that this class will only deal with enumerable properties of the source\n *  object; so it should be used to manipulate data objects. It will not deal\n *  with preserving the prototype-chain of the given object.\n *\n *  @author   Onur Yıldırım <onur@cutepilot.com>\n *  @license  MIT\n */\nclass Notation {\n\n    /**\n     *  Initializes a new instance of `Notation`.\n     *\n     *  @param {Object|Array} [source={}] - The source object (or array) to be\n     *  notated. Can either be an array or object. If omitted, defaults to an\n     *  empty object.\n     *  @param {Object} [options] - Notation options.\n     *      @param {Boolean} [options.strict=false] - Whether to throw either when\n     *      a notation path does not exist on the source (i.e. `#get()` and `#remove()`\n     *      methods); or notation path exists but overwriting is disabled (i.e.\n     *      `#set()` method). (Note that `.inspectGet()` and `.inspectRemove()` methods\n     *      are exceptions). It's recommended to set this to `true` and prevent silent\n     *      failures if you're working with sensitive data. Regardless of `strict` option,\n     *      it will always throw on invalid notation syntax or other crucial failures.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  const notation = new Notation(obj);\n     *  notation.get('car.model')   // » \"Charger\"\n     *  notation.remove('car.model').set('car.color', 'red').value\n     *  // » { car: { brand: \"Dodge\", year: 1970, color: \"red\" } }\n     */\n    constructor(source, options) {\n        if (arguments.length === 0) {\n            this._source = {};\n        } else if (!utils.isCollection(source)) {\n            throw new NotationError(ERR.SOURCE);\n        } else {\n            this._source = source;\n        }\n\n        this._isArray = utils.type(this._source) === 'array';\n        this.options = options;\n    }\n\n    // --------------------------------\n    // INSTANCE PROPERTIES\n    // --------------------------------\n\n    /**\n     *  Gets or sets notation options.\n     *  @type {Object}\n     */\n    get options() {\n        return this._options;\n    }\n\n    set options(value) {\n        this._options = {\n            ...DEFAULT_OPTS,\n            ...(this._options || {}),\n            ...(value || {})\n        };\n    }\n\n    /**\n     *  Gets the value of the source object.\n     *  @type {Object|Array}\n     *\n     *  @example\n     *  const person = { name: \"Onur\" };\n     *  const me = Notation.create(person)\n     *      .set(\"age\", 36)\n     *      .set(\"car.brand\", \"Ford\")\n     *      .set(\"car.model\", \"Mustang\")\n     *      .value;\n     *  console.log(me); // { name: \"Onur\", age: 36, car: { brand: \"Ford\", model: \"Mustang\" } }\n     *  console.log(person === me); // true\n     */\n    get value() {\n        return this._source;\n    }\n\n    // --------------------------------\n    // INSTANCE METHODS\n    // --------------------------------\n\n    /**\n     *  Recursively iterates through each key of the source object and invokes\n     *  the given callback function with parameters, on each non-object value.\n     *\n     *  @param {Function} callback - The callback function to be invoked on\n     *  each on each non-object value. To break out of the loop, return `false`\n     *  from within the callback.\n     *  Callback signature: `callback(notation, key, value, object) { ... }`\n     *\n     *  @returns {Notation} - The current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  Notation.create(obj).each(function (notation, key, value, object) {\n     *      console.log(notation, value);\n     *  });\n     *  // \"car.brand\"  \"Dodge\"\n     *  // \"car.model\"  \"Charger\"\n     *  // \"car.year\"  1970\n     */\n    each(callback) {\n        _each(this._source, callback);\n        return this;\n    }\n\n    /**\n     *  Iterates through each note of the given notation string by evaluating\n     *  it on the source object.\n     *\n     *  @param {String} notation - The notation string to be iterated through.\n     *  @param {Function} callback - The callback function to be invoked on\n     *  each iteration. To break out of the loop, return `false` from within\n     *  the callback. Signature: `callback(levelValue, note, index, list)`\n     *\n     *  @returns {Notation} - The current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  Notation.create(obj)\n     *      .eachValue(\"car.brand\", function (levelValue, note, index, list) {\n     *          console.log(note, levelValue); // \"car.brand\" \"Dodge\"\n     *      });\n     */\n    eachValue(notation, callback) {\n        let level = this._source;\n        Notation.eachNote(notation, (levelNotation, note, index, list) => {\n            level = utils.hasOwn(level, note) ? level[note] : undefined;\n            if (callback(level, levelNotation, note, index, list) === false) return false;\n\n        });\n        return this;\n    }\n\n    /**\n     *  Gets the list of notations from the source object (keys).\n     *\n     *  @returns {Array} - An array of notation strings.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  const notations = Notation.create(obj).getNotations();\n     *  console.log(notations); // [ \"car.brand\", \"car.model\", \"car.year\" ]\n     */\n    getNotations() {\n        const list = [];\n        this.each(notation => {\n            list.push(notation);\n        });\n        return list;\n    }\n\n    /**\n     *  Deeply clones the source object. This is also useful if you want to\n     *  prevent mutating the original source object.\n     *\n     *  <blockquote>\n     *  Note that `Notation` expects a data object (or array) with enumerable\n     *  properties. In addition to plain objects and arrays; supported cloneable\n     *  property/value types are primitives (such as `String`, `Number`,\n     *  `Boolean`, `Symbol`, `null` and `undefined`) and built-in types (such as\n     *  `Date` and `RegExp`).\n     *\n     *  Enumerable properties with types other than these (such as methods,\n     *  special objects, custom class instances, etc) will be copied by reference.\n     *  Non-enumerable properties will not be cloned.\n     *\n     *  If you still need full clone support, you can use a library like lodash.\n     *  e.g. `Notation.create(_.cloneDeep(source))`\n     *  </blockquote>\n     *\n     *  @returns {Notation} - The current `Notation` instance (self).\n     *\n     *  @example\n     *  const mutated = Notation.create(source1).set('newProp', true).value;\n     *  console.log(source1.newProp); // ——» true\n     *\n     *  const cloned = Notation.create(source2).clone().set('newProp', true).value;\n     *  console.log('newProp' in source2); // ——» false\n     *  console.log(cloned.newProp); // ——» true\n     */\n    clone() {\n        this._source = utils.cloneDeep(this._source);\n        return this;\n    }\n\n    /**\n     *  Flattens the source object to a single-level object with notated keys.\n     *\n     *  @returns {Notation} - The current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  console.log(Notation.create(obj).flatten().value);\n     *  // {\n     *  //     \"car.brand\": \"Dodge\",\n     *  //     \"car.model\": \"Charger\",\n     *  //     \"car.year\": 1970\n     *  // }\n     */\n    flatten() {\n        const o = {};\n        this.each((notation, key, value) => {\n            o[notation] = value;\n        });\n        this._source = o;\n        return this;\n    }\n\n    /**\n     *  Aggregates notated keys of a (single-level) object, and nests them under\n     *  their corresponding properties. This is the opposite of `Notation#flatten`\n     *  method. This might be useful when expanding a flat object fetched from\n     *  a database.\n     *  @alias Notation#aggregate\n     *  @chainable\n     *\n     *  @returns {Notation} - The current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { \"car.brand\": \"Dodge\", \"car.model\": \"Charger\", \"car.year\": 1970 }\n     *  const expanded = Notation.create(obj).expand().value;\n     *  console.log(expanded); // { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     */\n    expand() {\n        this._source = Notation.create({}).merge(this._source).value;\n        return this;\n    }\n\n    /**\n     *  Alias for `#expand`\n     *  @private\n     *  @returns {Notation} -\n     */\n    aggregate() {\n        return this.expand();\n    }\n\n    /**\n     *  Inspects the given notation on the source object by checking\n     *  if the source object actually has the notated property;\n     *  and getting its value if exists.\n     *  @param {String} notation - The notation string to be inspected.\n     *  @returns {InspectResult} - The result object.\n     *\n     *  @example\n     *  Notation.create({ car: { year: 1970 } }).inspectGet(\"car.year\");\n     *  // { has: true, value: 1970, lastNote: 'year', lastNoteNormalized: 'year' }\n     *  Notation.create({ car: { year: 1970 } }).inspectGet(\"car.color\");\n     *  // { has: false }\n     *  Notation.create({ car: { color: undefined } }).inspectGet(\"car.color\");\n     *  // { has: true, value: undefined, lastNote: 'color', lastNoteNormalized: 'color' }\n     *  Notation.create({ car: { brands: ['Ford', 'Dodge'] } }).inspectGet(\"car.brands[1]\");\n     *  // { has: true, value: 'Dodge', lastNote: '[1]', lastNoteNormalized: 1 }\n     */\n    inspectGet(notation) {\n        let level = this._source;\n        let result = { has: false, value: undefined };\n        let parent;\n        Notation.eachNote(notation, (levelNotation, note, index) => {\n            const lastNoteNormalized = utils.normalizeNote(note);\n            if (utils.hasOwn(level, lastNoteNormalized)) {\n                level = level[lastNoteNormalized];\n                parent = level;\n                result = {\n                    notation,\n                    has: true,\n                    value: level,\n                    type: utils.type(level),\n                    level: index + 1,\n                    lastNote: note,\n                    lastNoteNormalized\n                };\n            } else {\n                // level = undefined;\n                result = {\n                    notation,\n                    has: false,\n                    type: 'undefined',\n                    level: index + 1,\n                    lastNote: note,\n                    lastNoteNormalized\n                };\n                return false; // break out\n            }\n        });\n\n        if (parent === undefined || (result.has && parent === result.value)) parent = this._source;\n        result.parentIsArray = utils.type(parent) === 'array';\n\n        return result;\n    }\n\n    /**\n     *  Notation inspection result object.\n     *  @typedef Notation~InspectResult\n     *  @type Object\n     *  @property {String} notation - Notation that is inspected.\n     *  @property {Boolean} has - Indicates whether the source object has the\n     *  given notation as a (leveled) enumerable property. If the property\n     *  exists but has a value of `undefined`, this will still return `true`.\n     *  @property {*} value - The value of the notated property. If the source\n     *  object does not have the notation, the value will be `undefined`.\n     *  @property {String} type - The type of the notated property. If the source\n     *  object does not have the notation, the type will be `\"undefined\"`.\n     *  @property {String} lastNote - Last note of the notation, if actually\n     *  exists. For example, last note of `'a.b.c'` is `'c'`.\n     *  @property {String|Number} lastNoteNormalized - Normalized representation\n     *  of the last note of the notation, if actually exists. For example, last\n     *  note of `'a.b[1]` is `'[1]'` and will be normalized to number `1`; which\n     *  indicates an array index.\n     *  @property {Boolean} parentIsArray - Whether the parent object of the\n     *  notation path is an array.\n     */\n\n    /**\n     *  Inspects and removes the given notation from the source object by\n     *  checking if the source object actually has the notated property; and\n     *  getting its value if exists, before removing the property.\n     *\n     *  @param {String} notation - The notation string to be inspected.\n     *\n     *  @returns {InspectResult} - The result object.\n     *\n     *  @example\n     *  const obj = { name: \"John\", car: { year: 1970 } };\n     *  let result = Notation.create(obj).inspectRemove(\"car.year\");\n     *  // result » { notation: \"car.year\", has: true, value: 1970, lastNote: \"year\", lastNoteNormalized: \"year\" }\n     *  // obj » { name: \"John\", car: {} }\n     *\n     *  result = Notation.create({ car: { year: 1970 } }).inspectRemove(\"car.color\");\n     *  // result » { notation: \"car.color\", has: false }\n     *  Notation.create({ car: { color: undefined } }).inspectRemove(\"car['color']\");\n     *  // { notation: \"car.color\", has: true, value: undefined, lastNote: \"['color']\", lastNoteNormalized: \"color\" }\n     *\n     *  const obj = { car: { colors: [\"black\", \"white\"] } };\n     *  const result = Notation.create().inspectRemove(\"car.colors[0]\");\n     *  // result » { notation: \"car.colors[0]\", has: true, value: \"black\", lastNote: \"[0]\", lastNoteNormalized: 0 }\n     *  // obj » { car: { colors: [(empty), \"white\"] } }\n     */\n    inspectRemove(notation) {\n        if (!notation) throw new Error(ERR.NOTATION + `'${notation}'`);\n        const parentNotation = Notation.parent(notation);\n        const parent = parentNotation ? this.get(parentNotation, null) : this._source;\n        const parentIsArray = utils.type(parent) === 'array';\n        const notes = Notation.split(notation);\n        const lastNote = notes[notes.length - 1];\n        const lastNoteNormalized = utils.normalizeNote(lastNote);\n\n        let result, value;\n        if (utils.hasOwn(parent, lastNoteNormalized)) {\n            value = parent[lastNoteNormalized];\n            result = {\n                notation,\n                has: true,\n                value,\n                type: utils.type(value),\n                level: notes.length,\n                lastNote,\n                lastNoteNormalized,\n                parentIsArray\n            };\n\n            // if `preserveIndices` is enabled and this is an array, we'll\n            // splice the item out. otherwise, we'll use `delete` syntax to\n            // empty the item.\n            if (!this.options.preserveIndices && parentIsArray) {\n                parent.splice(lastNoteNormalized, 1);\n            } else {\n                delete parent[lastNoteNormalized];\n            }\n        } else {\n            result = {\n                notation,\n                has: false,\n                type: 'undefined',\n                level: notes.length,\n                lastNote,\n                lastNoteNormalized,\n                parentIsArray\n            };\n        }\n\n        return result;\n    }\n\n    /**\n     *  Checks whether the source object has the given notation\n     *  as a (leveled) enumerable property. If the property exists\n     *  but has a value of `undefined`, this will still return `true`.\n     *  @param {String} notation - The notation string to be checked.\n     *  @returns {Boolean} -\n     *\n     *  @example\n     *  Notation.create({ car: { year: 1970 } }).has(\"car.year\"); // true\n     *  Notation.create({ car: { year: undefined } }).has(\"car.year\"); // true\n     *  Notation.create({}).has(\"car.color\"); // false\n     */\n    has(notation) {\n        return this.inspectGet(notation).has;\n    }\n\n    /**\n     *  Checks whether the source object has the given notation\n     *  as a (leveled) defined enumerable property. If the property\n     *  exists but has a value of `undefined`, this will return `false`.\n     *  @param {String} notation - The notation string to be checked.\n     *  @returns {Boolean} -\n     *\n     *  @example\n     *  Notation.create({ car: { year: 1970 } }).hasDefined(\"car.year\"); // true\n     *  Notation.create({ car: { year: undefined } }).hasDefined(\"car.year\"); // false\n     *  Notation.create({}).hasDefined(\"car.color\"); // false\n     */\n    hasDefined(notation) {\n        return this.inspectGet(notation).value !== undefined;\n    }\n\n    /**\n     *  Gets the value of the corresponding property at the given notation.\n     *\n     *  @param {String} notation - The notation string to be processed.\n     *  @param {String} [defaultValue] - The default value to be returned if the\n     *  property is not found or enumerable.\n     *\n     *  @returns {*} - The value of the notated property.\n     *  @throws {NotationError} - If `strict` option is enabled, `defaultValue`\n     *  is not set and notation does not exist.\n     *\n     *  @example\n     *  Notation.create({ car: { brand: \"Dodge\" } }).get(\"car.brand\"); // \"Dodge\"\n     *  Notation.create({ car: {} }).get(\"car.model\", \"Challenger\"); // \"Challenger\"\n     *  Notation.create({ car: { model: undefined } }).get(\"car.model\", \"Challenger\"); // undefined\n     *\n     *  @example <caption>get value when strict option is enabled</caption>\n     *  // strict option defaults to false\n     *  Notation.create({ car: {} }).get(\"car.model\"); // undefined\n     *  Notation.create({ car: {} }, { strict: false }).get(\"car.model\"); // undefined\n     *  // below will throw bec. strict = true, car.model does not exist\n     *  // and no default value is given.\n     *  Notation.create({ car: {} }, { strict: true }).get(\"car.model\");\n     */\n    get(notation, defaultValue) {\n        const result = this.inspectGet(notation);\n        // if strict and no default value is set, check if implied index or prop\n        // exists\n        if (this.options.strict && arguments.length < 2 && !result.has) {\n            const msg = result.parentIsArray ? ERR.NO_INDEX : ERR.NO_PROP;\n            throw new NotationError(msg + `'${notation}'`);\n        }\n        return result.has ? result.value : defaultValue;\n    }\n\n    /**\n     *  Sets the value of the corresponding property at the given notation. If\n     *  the property does not exist, it will be created and nested at the\n     *  calculated level. If it exists; its value will be overwritten by\n     *  default.\n     *  @chainable\n     *\n     *  @param {String} notation - The notation string to be processed.\n     *  @param {*} value - The value to be set for the notated property.\n     *  @param {String|Boolean} [mode=\"overwrite\"] - Write mode. By default,\n     *  this is set to `\"overwrite\"` which sets the value by overwriting the\n     *  target object property or array item at index. To insert an array item\n     *  (by shifting the index, instead of overwriting); set to `\"insert\"`. To\n     *  prevent overwriting the value if exists, explicitly set to `false`.\n     *\n     *  @returns {Notation} - The current `Notation` instance (self).\n     *\n     *  @throws {NotationError} - If strict notation is enabled, `overwrite`\n     *  option is set to `false` and attempted to overwrite an existing value.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", year: 1970 } };\n     *  Notation.create(obj)\n     *      .set(\"car.brand\", \"Ford\")\n     *      .set(\"car.model\", \"Mustang\")\n     *      .set(\"car.year\", 1965, false)\n     *      .set(\"car.color\", \"red\")\n     *      .set(\"boat\", \"none\");\n     *  console.log(obj);\n     *  // { notebook: \"Mac\", car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" }, boat: \"none\" };\n     */\n    set(notation, value, mode = 'overwrite') {\n        if (!notation.trim()) throw new NotationError(ERR.NOTATION + `'${notation}'`);\n        if (mode === true) mode = 'overwrite';\n        let level = this._source;\n        let currentIsLast, nCurrentNote, nNextNote, nextIsArrayNote, type;\n        const insertErrMsg = 'Cannot set value by inserting at index, on an object';\n\n        Notation.eachNote(notation, (levelNotation, note, index, list) => {\n            currentIsLast = index === list.length - 1;\n            nCurrentNote = nNextNote || utils.normalizeNote(note);\n            nNextNote = currentIsLast ? null : utils.normalizeNote(list[index + 1]);\n            type = utils.type(level);\n\n            if (type === 'array' && typeof nCurrentNote !== 'number') {\n                const parent = Notation.parent(levelNotation) || 'source';\n                throw new NotationError(`Cannot set string key '${note}' on array ${parent}`);\n            }\n\n            // check if the property is at this level\n            if (utils.hasOwn(level, nCurrentNote, type)) {\n                // check if we're at the last level\n                if (currentIsLast) {\n                    // if mode is \"overwrite\", assign the value.\n                    if (mode === 'overwrite') {\n                        level[nCurrentNote] = value;\n                    } else if (mode === 'insert') {\n                        if (type === 'array') {\n                            level.splice(nCurrentNote, 0, value);\n                        } else {\n                            throw new NotationError(insertErrMsg);\n                        }\n                    }\n                    // otherwise, will not overwrite\n                } else {\n                    // if not last level; just re-reference the current level.\n                    level = level[nCurrentNote];\n                }\n            } else {\n                if (currentIsLast && type !== 'array' && mode === 'insert') {\n                    throw new NotationError(insertErrMsg);\n                }\n\n                // if next normalized note is a number, it indicates that the\n                // current note is actually an array.\n                nextIsArrayNote = typeof nNextNote === 'number';\n\n                // we don't have this property at this level so; if this is the\n                // last level, we set the value if not, we set an empty\n                // collection for the next level\n                level[nCurrentNote] = (currentIsLast ? value : (nextIsArrayNote ? [] : {}));\n                level = level[nCurrentNote];\n            }\n        });\n        return this;\n    }\n\n    /**\n     *  Just like the `.set()` method but instead of a single notation\n     *  string, an object of notations and values can be passed.\n     *  Sets the value of each corresponding property at the given\n     *  notation. If a property does not exist, it will be created\n     *  and nested at the calculated level. If it exists; its value\n     *  will be overwritten by default.\n     *  @chainable\n     *\n     *  @param {Object} notationsObject - The notations object to be processed.\n     *  This can either be a regular object with non-dotted keys\n     *  (which will be merged to the first/root level of the source object);\n     *  or a flattened object with notated (dotted) keys.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite a property if\n     *  exists.\n     *\n     *  @returns {Notation} - The current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", year: 1970 } };\n     *  Notation.create(obj).merge({\n     *      \"car.brand\": \"Ford\",\n     *      \"car.model\": \"Mustang\",\n     *      \"car.year\": 1965,\n     *      \"car.color\": \"red\",\n     *      \"boat\": \"none\"\n     *  });\n     *  console.log(obj);\n     *  // { car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" }, boat: \"none\" };\n     */\n    merge(notationsObject, overwrite = true) {\n        if (utils.type(notationsObject) !== 'object') {\n            throw new NotationError(ERR.NOTA_OBJ + 'Expected an object.');\n        }\n        let value;\n        utils.each(Object.keys(notationsObject), notation => {\n            value = notationsObject[notation];\n            this.set(notation, value, overwrite);\n        });\n        return this;\n    }\n\n    /**\n     *  Removes the properties by the given list of notations from the source\n     *  object and returns a new object with the removed properties.\n     *  Opposite of `merge()` method.\n     *\n     *  @param {Array} notations - The notations array to be processed.\n     *\n     *  @returns {Object} - An object with the removed properties.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", year: 1970 }, notebook: \"Mac\" };\n     *  const separated = Notation.create(obj).separate([\"car.brand\", \"boat\" ]);\n     *  console.log(separated);\n     *  // { notebook: \"Mac\", car: { brand: \"Ford\" } };\n     *  console.log(obj);\n     *  // { car: { year: 1970 } };\n     */\n    separate(notations) {\n        if (utils.type(notations) !== 'array') {\n            throw new NotationError(ERR.NOTA_OBJ + 'Expected an array.');\n        }\n        const o = new Notation({});\n        utils.each(notations, notation => {\n            const result = this.inspectRemove(notation);\n            o.set(notation, result.value);\n        });\n        this._source = o._source;\n        return this;\n    }\n\n    /**\n     *  Deep clones the source object while filtering its properties by the\n     *  given <b>glob</b> notations. Includes all matched properties and removes\n     *  the rest.\n     *\n     *  The difference between regular notations and glob-notations is that;\n     *  with the latter, you can use wildcard stars (*) and negate the notation\n     *  by prepending a bang (!). A negated notation will be excluded.\n     *\n     *  Order of the globs does not matter; they will be logically sorted. Loose\n     *  globs will be processed first and verbose globs or normal notations will\n     *  be processed last. e.g. `[ \"car.model\", \"*\", \"!car.*\" ]` will be\n     *  normalized and sorted as `[ \"*\", \"!car\" ]`.\n     *\n     *  Passing no parameters or passing a glob of `\"!*\"` or `[\"!*\"]` will empty\n     *  the source object. See `Notation.Glob` class for more information.\n     *  @chainable\n     *\n     *  @param {Array|String} globList - Glob notation list to be processed.\n     *  @param {Object} [options] - Filter options.\n     *  @param {Boolean} [options.restrictive=false] - Whether negated items\n     *  strictly remove every match. Note that, regardless of this option, if\n     *  any item has an exact negated version; non-negated is always removed.\n     *\n     *  @returns {Notation} - The current `Notation` instance (self). To get the\n     *  filtered value, call `.value` property on the instance.\n     *\n     *  @example\n     *  const car = { brand: \"Ford\", model: { name: \"Mustang\", year: 1970 } };\n     *  const n = Notation.create(car);\n     *\n     *  console.log(n.filter([ \"*\", \"!model.year\" ]).value);  // { brand: \"Ford\", model: { name: \"Mustang\" } }\n     *  console.log(n.filter(\"model.name\").value);            // { model: { name: \"Mustang\" } }\n     *  console.log(car);                                     // { brand: \"Ford\", model: { name: \"Mustang\", year: 1970 } }\n     *  console.log(n.filter().value);                        // {} // —» equivalent to n.filter(\"\") or n.filter(\"!*\")\n     */\n    filter(globList, options = {}) {\n        const { re } = utils;\n\n        // ensure array, normalize and sort the globs in logical order. this\n        // also concats the array first (to prevent mutating the original\n        // array).\n        const globs = Glob.normalize(globList, options.restrictive);\n        const len = globs.length;\n        const empty = this._isArray ? [] : {};\n\n        // if globs is \"\" or [\"\"] or [\"!*\"] or [\"![*]\"] set source to empty and return.\n        if (len === 0 || (len === 1 && (!globs[0] || re.NEGATE_ALL.test(globs[0])))) {\n            this._source = empty;\n            return this;\n        }\n\n        const cloned = utils.cloneDeep(this.value);\n\n        const firstIsWildcard = re.WILDCARD.test(globs[0]);\n        // if globs only consist of \"*\" or \"[*]\"; set the \"clone\" as source and\n        // return.\n        if (len === 1 && firstIsWildcard) {\n            this._source = cloned;\n            return this;\n        }\n\n        let filtered;\n        // if the first item of sorted globs is \"*\" or \"[*]\" we set the source\n        // to the (full) \"copy\" and remove the wildcard from globs (not to\n        // re-process).\n        if (firstIsWildcard) {\n            filtered = new Notation(cloned);\n            globs.shift();\n        } else {\n            // otherwise we set an empty object or array as the source so that\n            // we can add notations/properties to it.\n            filtered = new Notation(empty);\n        }\n\n        // iterate through globs\n        utils.each(globs, globNotation => {\n            // console.log('globNotation', globNotation);\n            const g = new Glob(globNotation);\n            const { glob, absGlob, isNegated, levels } = g;\n            let normalized, emptyValue, eType;\n            // check whether the glob ends with `.*` or `[*]` then remove\n            // trailing glob note and decide for empty value (if negated). for\n            // non-negated, trailing wildcards are already removed by\n            // normalization.\n            if (absGlob.slice(-2) === '.*') {\n                normalized = absGlob.slice(0, -2);\n                /* istanbul ignore else */\n                if (isNegated) emptyValue = {};\n                eType = 'object';\n            } else if (absGlob.slice(-3) === '[*]') {\n                normalized = absGlob.slice(0, -3);\n                /* istanbul ignore else */\n                if (isNegated) emptyValue = [];\n                eType = 'array';\n            } else {\n                normalized = absGlob;\n            }\n\n            // we'll check glob vs value integrity if emptyValue is set; and throw if needed.\n            const errGlobIntegrity = `Integrity failed for glob '${glob}'. Cannot set empty ${eType} for '${normalized}' which has a type of `; // ...\n\n            // check if remaining normalized glob has no wildcard stars e.g.\n            // \"a.b\" or \"!a.b.c\" etc..\n            if (re.WILDCARDS.test(normalized) === false) {\n                if (isNegated) {\n                    // inspect and directly remove the notation if negated.\n                    // we need the inspection for the detailed error below.\n                    const insRemove = filtered.inspectRemove(normalized);\n                    // console.log('insRemove', insRemove);\n\n                    // if original glob had `.*` at the end, it means remove\n                    // contents (not itself). so we'll set an empty object.\n                    // meaning `some.prop` (prop) is removed completely but\n                    // `some.prop.*` (prop) results in `{}`. For array notation\n                    // (`[*]`), we'll set an empty array.\n                    if (emptyValue) {\n                        // e.g. for glob `![0].x.*` we expect to set `[0].x = {}`\n                        // but if `.x` is not an object (or array), we should fail.\n                        const vType = insRemove.type;\n                        const errMsg = errGlobIntegrity + `'${vType}'.`;\n                        // in non-strict mode, only exceptions are `null` and\n                        // `undefined`, for which we won't throw but we'll not\n                        // set an empty obj/arr either.\n\n                        const isValSet = utils.isset(insRemove.value);\n                        // on critical type mismatch we throw\n                        // or if original value is undefined or null in strict mode we throw\n                        if ((isValSet && vType !== eType) || (!isValSet && this.options.strict)) {\n                            throw new NotationError(errMsg);\n                        }\n                        // if parent is an array, we'll insert the value at\n                        // index bec. we've removed the item and indexes are\n                        // shifted. Otherwise, we'll simply overwrite the\n                        // object property value.\n                        const setMode = insRemove.parentIsArray ? 'insert' : 'overwrite';\n                        // console.log('setting', normalized, emptyValue, setMode);\n                        filtered.set(normalized, emptyValue, setMode);\n                    }\n                } else {\n                    // directly set the same notation from the original\n                    const insGet = this.inspectGet(normalized); // Notation.create(original).inspectGet ...\n                    /* istanbul ignore else */\n                    if (insGet.has) filtered.set(normalized, insGet.value, 'overwrite');\n                }\n                // move to the next\n                return true;\n            }\n\n            // if glob has wildcard(s), we'll iterate through keys of the source\n            // object and see if (full) notation of each key matches the current\n            // glob.\n\n            // important! we will iterate with eachRight to prevent shifted\n            // indexes when removing items from arrays.\n            const reverseIterateIfArray = true;\n\n            _each(this._source, (originalNotation, key, value) => {\n                const originalIsCovered = Glob.create(normalized).covers(originalNotation);\n                // console.log('» normalized:', normalized, 'covers', originalNotation, '»', originalIsCovered);\n                if (!originalIsCovered) return true; // break\n\n                if (this.options.strict && emptyValue) {\n                    // since original is covered and we have emptyValue set (due\n                    // to trailing wildcard), here we'll check value vs glob\n                    // integrity; (only if we're in strict mode).\n\n                    const vType = utils.type(value);\n                    // types and number of levels are the same?\n                    if (vType !== eType\n                            // we subtract 1 from number of levels bec. the last\n                            // note is removed since we have emptyValue set.\n                            && Notation.split(originalNotation).length === levels.length - 1) {\n                        throw new NotationError(errGlobIntegrity + `'${vType}'.`);\n                    }\n                }\n\n                // iterating each note of original notation. i.e.:\n                // note1.note2.note3 is iterated from left to right, as:\n                // 'note1', 'note1.note2', 'note1.note2.note3' — in order.\n                Notation.eachNote(originalNotation, levelNotation => {\n                    // console.log('  level »', glob, 'covers', levelNotation, '»', g.test(levelNotation));\n\n                    if (g.test(levelNotation)) {\n                        const levelLen = Notation.split(levelNotation).length;\n                        /* istanbul ignore else */\n                        if (isNegated && levels.length <= levelLen) {\n                            // console.log('  » removing', levelNotation, 'of', originalNotation);\n                            filtered.remove(levelNotation);\n                            // we break and return early if removed bec. e.g.\n                            // when 'note1.note2' (parent) of\n                            // 'note1.note2.note3' is also removed, we no more\n                            // have 'note3'.\n                            return false;\n                        }\n                        // console.log('  » setting', levelNotation, '=', value);\n                        filtered.set(levelNotation, value, 'overwrite');\n                    }\n                });\n            }, reverseIterateIfArray);\n        });\n        // finally set the filtered's value as the source of our instance and\n        // return.\n        this._source = filtered.value;\n        return this;\n    }\n\n    /**\n     *  Removes the property from the source object, at the given notation.\n     *  @alias Notation#delete\n     *  @chainable\n     *  @param {String} notation - The notation to be inspected.\n     *  @returns {Notation} - The current `Notation` instance (self).\n     *  @throws {NotationError} - If `strict` option is enabled and notation\n     *  does not exist.\n     *\n     *  @example\n     *  const obj = { notebook: \"Mac\", car: { model: \"Mustang\" } };\n     *  Notation.create(obj).remove(\"car.model\");\n     *  console.log(obj); // { notebook: \"Mac\", car: { } }\n     */\n    remove(notation) {\n        const result = this.inspectRemove(notation);\n        // if strict, check if implied index or prop exists\n        if (this.options.strict && !result.has) {\n            const msg = result.parentIsArray ? ERR.NO_INDEX : ERR.NO_PROP;\n            throw new NotationError(msg + `'${notation}'`);\n        }\n        return this;\n    }\n\n    /**\n     *  Alias of `Notation#remove`\n     *  @private\n     *  @param {String} notation -\n     *  @returns {Notation} -\n     */\n    delete(notation) {\n        this.remove(notation);\n        return this;\n    }\n\n    /**\n     *  Copies the notated property from the source collection and adds it to the\n     *  destination — only if the source object actually has that property.\n     *  This is different than a property with a value of `undefined`.\n     *  @chainable\n     *\n     *  @param {Object|Array} destination - The destination object that the notated\n     *  properties will be copied to.\n     *  @param {String} notation - The notation to get the corresponding property\n     *  from the source object.\n     *  @param {String} [newNotation=null] - The notation to set the source property\n     *  on the destination object. In other words, the copied property will be\n     *  renamed to this value before set on the destination object. If not set,\n     *  `notation` argument will be used.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\n     *  the destination object if it exists.\n     *\n     *  @returns {Notation} - The current `Notation` instance (self).\n     *\n     *  @throws {NotationError} - If `destination` is not a valid collection.\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const models = { dodge: \"Charger\" };\n     *  Notation.create(obj).copyTo(models, \"car.model\", \"ford\");\n     *  console.log(models);\n     *  // { dodge: \"Charger\", ford: \"Mustang\" }\n     *  // source object (obj) is not modified\n     */\n    copyTo(destination, notation, newNotation = null, overwrite = true) {\n        if (!utils.isCollection(destination)) throw new NotationError(ERR.DEST);\n        const result = this.inspectGet(notation);\n        if (result.has) {\n            const newN = utils.getNewNotation(newNotation, notation);\n            Notation.create(destination).set(newN, result.value, overwrite);\n        }\n        return this;\n    }\n\n    /**\n     *  Copies the notated property from the target collection and adds it to\n     *  (own) source object — only if the target object actually has that\n     *  property. This is different than a property with a value of `undefined`.\n     *  @chainable\n     *\n     *  @param {Object|Array} target - The target collection that the notated\n     *  properties will be copied from.\n     *  @param {String} notation - The notation to get the corresponding\n     *  property from the target object.\n     *  @param {String} [newNotation=null] - The notation to set the copied\n     *  property on our source collection. In other words, the copied property\n     *  will be renamed to this value before set. If not set, `notation`\n     *  argument will be used.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\n     *  our collection if it exists.\n     *\n     *  @returns {Notation} - The current `Notation` instance (self).\n     *\n     *  @throws {NotationError} - If `target` is not a valid collection.\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const models = { dodge: \"Charger\" };\n     *  Notation.create(obj).copyFrom(models, \"dodge\", \"car.model\", true);\n     *  console.log(obj);\n     *  // { car: { brand: \"Ford\", model: \"Charger\" } }\n     *  // models object is not modified\n     */\n    copyFrom(target, notation, newNotation = null, overwrite = true) {\n        if (!utils.isCollection(target)) throw new NotationError(ERR.DEST);\n        const result = Notation.create(target).inspectGet(notation);\n        if (result.has) {\n            const newN = utils.getNewNotation(newNotation, notation);\n            this.set(newN, result.value, overwrite);\n        }\n        return this;\n    }\n\n    /**\n     *  Removes the notated property from the source (own) collection and adds\n     *  it to the destination — only if the source collection actually has that\n     *  property. This is different than a property with a value of `undefined`.\n     *  @chainable\n     *\n     *  @param {Object|Array} destination - The destination collection that the\n     *  notated properties will be moved to.\n     *  @param {String} notation - The notation to get the corresponding\n     *  property from the source object.\n     *  @param {String} [newNotation=null] - The notation to set the source\n     *  property on the destination object. In other words, the moved property\n     *  will be renamed to this value before set on the destination object. If\n     *  not set, `notation` argument will be used.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\n     *  the destination object if it exists.\n     *\n     *  @returns {Notation} - The current `Notation` instance (self).\n     *\n     *  @throws {NotationError} - If `destination` is not a valid collection.\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const models = { dodge: \"Charger\" };\n     *  Notation.create(obj).moveTo(models, \"car.model\", \"ford\");\n     *  console.log(obj);\n     *  // { car: { brand: \"Ford\" } }\n     *  console.log(models);\n     *  // { dodge: \"Charger\", ford: \"Mustang\" }\n     */\n    moveTo(destination, notation, newNotation = null, overwrite = true) {\n        if (!utils.isCollection(destination)) throw new NotationError(ERR.DEST);\n        const result = this.inspectRemove(notation);\n        if (result.has) {\n            const newN = utils.getNewNotation(newNotation, notation);\n            Notation.create(destination).set(newN, result.value, overwrite);\n        }\n        return this;\n    }\n\n    /**\n     *  Removes the notated property from the target collection and adds it to (own)\n     *  source collection — only if the target object actually has that property.\n     *  This is different than a property with a value of `undefined`.\n     *  @chainable\n     *\n     *  @param {Object|Array} target - The target collection that the notated\n     *  properties will be moved from.\n     *  @param {String} notation - The notation to get the corresponding property\n     *  from the target object.\n     *  @param {String} [newNotation=null] - The notation to set the target\n     *  property on the source object. In other words, the moved property\n     *  will be renamed to this value before set on the source object.\n     *  If not set, `notation` argument will be used.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\n     *  the source object if it exists.\n     *\n     *  @returns {Notation} - The current `Notation` instance (self).\n     *\n     *  @throws {NotationError} - If `target` is not a valid collection.\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const models = { dodge: \"Charger\" };\n     *  Notation.create(obj).moveFrom(models, \"dodge\", \"car.model\", true);\n     *  console.log(obj);\n     *  // { car: { brand: \"Ford\", model: \"Charger\" } }\n     *  console.log(models);\n     *  // {}\n     */\n    moveFrom(target, notation, newNotation = null, overwrite = true) {\n        if (!utils.isCollection(target)) throw new NotationError(ERR.DEST);\n        const result = Notation.create(target).inspectRemove(notation);\n        if (result.has) {\n            const newN = utils.getNewNotation(newNotation, notation);\n            this.set(newN, result.value, overwrite);\n        }\n        return this;\n    }\n\n    /**\n     *  Renames the notated property of the source collection by the new notation.\n     *  @alias Notation#renote\n     *  @chainable\n     *\n     *  @param {String} notation - The notation to get the corresponding\n     *  property (value) from the source collection.\n     *  @param {String} newNotation - The new notation for the targeted\n     *  property value. If not set, the source collection will not be modified.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property at\n     *  the new notation, if it exists.\n     *\n     *  @returns {Notation} - The current `Notation` instance (self).\n     *\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  Notation.create(obj)\n     *      .rename(\"car.brand\", \"carBrand\")\n     *      .rename(\"car.model\", \"carModel\");\n     *  console.log(obj);\n     *  // { carBrand: \"Ford\", carModel: \"Mustang\" }\n     */\n    rename(notation, newNotation, overwrite) {\n        return this.moveTo(this._source, notation, newNotation, overwrite);\n    }\n\n    /**\n     *  Alias for `#rename`\n     *  @private\n     *  @param {String} notation -\n     *  @param {String} newNotation -\n     *  @param {Boolean} [overwrite=true] -\n     *  @returns {Notation} -\n     */\n    renote(notation, newNotation, overwrite) {\n        return this.rename(notation, newNotation, overwrite);\n    }\n\n    /**\n     *  Extracts the property at the given notation to a new object by copying\n     *  it from the source collection. This is equivalent to `.copyTo({},\n     *  notation, newNotation)`.\n     *  @alias Notation#copyToNew\n     *\n     *  @param {String} notation - The notation to get the corresponding\n     *  property (value) from the source object.\n     *  @param {String} newNotation - The new notation to be set on the new\n     *  object for the targeted property value. If not set, `notation` argument\n     *  will be used.\n     *\n     *  @returns {Object} - Returns a new object with the notated property.\n     *\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const extracted = Notation.create(obj).extract(\"car.brand\", \"carBrand\");\n     *  console.log(extracted);\n     *  // { carBrand: \"Ford\" }\n     *  // obj is not modified\n     */\n    extract(notation, newNotation) {\n        const o = {};\n        this.copyTo(o, notation, newNotation);\n        return o;\n    }\n\n    /**\n     *  Alias for `#extract`\n     *  @private\n     *  @param {String} notation -\n     *  @param {String} newNotation -\n     *  @returns {Object} -\n     */\n    copyToNew(notation, newNotation) {\n        return this.extract(notation, newNotation);\n    }\n\n    /**\n     *  Extrudes the property at the given notation to a new collection by\n     *  moving it from the source collection. This is equivalent to `.moveTo({},\n     *  notation, newNotation)`.\n     *  @alias Notation#moveToNew\n     *\n     *  @param {String} notation - The notation to get the corresponding\n     *  property (value) from the source object.\n     *  @param {String} newNotation - The new notation to be set on the new\n     *  object for the targeted property value. If not set, `notation` argument\n     *  will be used.\n     *\n     *  @returns {Object} - Returns a new object with the notated property.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const extruded = Notation.create(obj).extrude(\"car.brand\", \"carBrand\");\n     *  console.log(obj);\n     *  // { car: { model: \"Mustang\" } }\n     *  console.log(extruded);\n     *  // { carBrand: \"Ford\" }\n     */\n    extrude(notation, newNotation) {\n        const o = {};\n        this.moveTo(o, notation, newNotation);\n        return o;\n    }\n\n    /**\n     *  Alias for `#extrude`\n     *  @private\n     *  @param {String} notation -\n     *  @param {String} newNotation -\n     *  @returns {Object} -\n     */\n    moveToNew(notation, newNotation) {\n        return this.extrude(notation, newNotation);\n    }\n\n    // --------------------------------\n    // STATIC MEMBERS\n    // --------------------------------\n\n    /**\n     *  Basically constructs a new `Notation` instance.\n     *  @chainable\n     *  @param {Object|Array} [source={}] - The source collection to be notated.\n     *  @param {Object} [options] - Notation options.\n     *      @param {Boolean} [options.strict=false] - Whether to throw when a\n     *      notation path does not exist on the source. (Note that `.inspectGet()`\n     *      and `.inspectRemove()` methods are exceptions). It's recommended to\n     *      set this to `true` and prevent silent failures if you're working\n     *      with sensitive data. Regardless of `strict` option, it will always\n     *      throw on invalid notation syntax or other crucial failures.\n     *\n     *  @returns {Notation} - The created instance.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  const notation = Notation.create(obj); // equivalent to new Notation(obj)\n     *  notation.get('car.model')   // » \"Charger\"\n     *  notation.remove('car.model').set('car.color', 'red').value\n     *  // » { car: { brand: \"Dodge\", year: 1970, color: \"red\" } }\n     */\n    static create(source, options) {\n        if (arguments.length === 0) {\n            return new Notation({});\n        }\n        return new Notation(source, options);\n    }\n\n    /**\n     *  Checks whether the given notation string is valid. Note that the star\n     *  (`*`) (which is a valid character, even if irregular) is NOT treated as\n     *  wildcard here. This checks for regular dot-notation, not a glob-notation.\n     *  For glob notation validation, use `Notation.Glob.isValid()` method. Same\n     *  goes for the negation character/prefix (`!`).\n     *\n     *  @param {String} notation - The notation string to be checked.\n     *  @returns {Boolean} -\n     *\n     *  @example\n     *  Notation.isValid('prop1.prop2.prop3'); // true\n     *  Notation.isValid('x'); // true\n     *  Notation.isValid('x.arr[0].y'); // true\n     *  Notation.isValid('x[\"*\"]'); // true\n     *  Notation.isValid('x.*'); // false (this would be valid for Notation#filter() only or Notation.Glob class)\n     *  Notation.isValid('@1'); // false (should be \"['@1']\")\n     *  Notation.isValid(null); // false\n     */\n    static isValid(notation) {\n        return typeof notation === 'string' && reVALIDATOR.test(notation);\n    }\n\n    /**\n     *  Splits the given notation string into its notes (levels).\n     *  @param {String} notation  Notation string to be splitted.\n     *  @returns {Array} - A string array of notes (levels).\n     *  @throws {NotationError} - If given notation is invalid.\n     */\n    static split(notation) {\n        if (!Notation.isValid(notation)) {\n            throw new NotationError(ERR.NOTATION + `'${notation}'`);\n        }\n        return notation.match(reMATCHER);\n    }\n\n    /**\n     *  Joins the given notes into a notation string.\n     *  @param {String} notes  Notes (levels) to be joined.\n     *  @returns {String}  Joined notation string.\n     */\n    static join(notes) {\n        return utils.joinNotes(notes);\n    }\n\n    /**\n     *  Counts the number of notes/levels in the given notation.\n     *  @alias Notation.countLevels\n     *  @param {String} notation - The notation string to be processed.\n     *  @returns {Number} - Number of notes.\n     *  @throws {NotationError} - If given notation is invalid.\n     */\n    static countNotes(notation) {\n        return Notation.split(notation).length;\n    }\n\n    /**\n     *  Alias of `Notation.countNotes`.\n     *  @private\n     *  @param {String} notation -\n     *  @returns {Number} -\n     */\n    static countLevels(notation) {\n        return Notation.countNotes(notation);\n    }\n\n    /**\n     *  Gets the first (root) note of the notation string.\n     *  @param {String} notation - The notation string to be processed.\n     *  @returns {String} - First note.\n     *  @throws {NotationError} - If given notation is invalid.\n     *\n     *  @example\n     *  Notation.first('first.prop2.last'); // \"first\"\n     */\n    static first(notation) {\n        return Notation.split(notation)[0];\n    }\n\n    /**\n     *  Gets the last note of the notation string.\n     *  @param {String} notation - The notation string to be processed.\n     *  @returns {String} - Last note.\n     *  @throws {NotationError} - If given notation is invalid.\n     *\n     *  @example\n     *  Notation.last('first.prop2.last'); // \"last\"\n     */\n    static last(notation) {\n        const list = Notation.split(notation);\n        return list[list.length - 1];\n    }\n\n    /**\n     *  Gets the parent notation (up to but excluding the last note)\n     *  from the notation string.\n     *  @param {String} notation - The notation string to be processed.\n     *  @returns {String} - Parent note if any. Otherwise, `null`.\n     *  @throws {NotationError} - If given notation is invalid.\n     *\n     *  @example\n     *  Notation.parent('first.prop2.last'); // \"first.prop2\"\n     *  Notation.parent('single'); // null\n     */\n    static parent(notation) {\n        const last = Notation.last(notation);\n        return notation.slice(0, -last.length).replace(/\\.$/, '') || null;\n    }\n\n    /**\n     *  Iterates through each note/level of the given notation string.\n     *  @alias Notation.eachLevel\n     *\n     *  @param {String} notation - The notation string to be iterated through.\n     *  @param {Function} callback - The callback function to be invoked on\n     *  each iteration. To break out of the loop, return `false` from within the\n     *  callback.\n     *  Callback signature: `callback(levelNotation, note, index, list) { ... }`\n     *\n     *  @returns {void}\n     *  @throws {NotationError} - If given notation is invalid.\n     *\n     *  @example\n     *  const notation = 'first.prop2.last';\n     *  Notation.eachNote(notation, function (levelNotation, note, index, list) {\n     *      console.log(index, note, levelNotation);\n     *  });\n     *  // 0  \"first\"             \"first\"\n     *  // 1  \"first.prop2\"       \"prop2\"\n     *  // 2  \"first.prop2.last\"  \"last\"\n     */\n    static eachNote(notation, callback) {\n        const notes = Notation.split(notation);\n        const levelNotes = [];\n        utils.each(notes, (note, index) => {\n            levelNotes.push(note);\n            if (callback(Notation.join(levelNotes), note, index, notes) === false) return false;\n        }, Notation);\n    }\n\n    /**\n     *  Alias of `Notation.eachNote`.\n     *  @private\n     *  @param {String} notation -\n     *  @param {Function} callback -\n     *  @returns {void}\n     */\n    static eachLevel(notation, callback) {\n        Notation.eachNote(notation, callback);\n    }\n\n}\n\n/**\n *  Error class specific to `Notation`.\n *  @private\n *\n *  @class\n *  @see `{@link #Notation.Error}`\n */\nNotation.Error = NotationError;\n\n/**\n *  Utility for validating, comparing and sorting dot-notation globs.\n *  This is internally used by `Notation` class.\n *  @private\n *\n *  @class\n *  @see `{@link #Notation.Glob}`\n */\nNotation.Glob = Glob;\n\n/**\n *  Undocumented\n *  @private\n */\nNotation.utils = utils;\n\n// --------------------------------\n// HELPERS\n// --------------------------------\n\n/**\n *  Deep iterates through each note (level) of each item in the given\n *  collection.\n *  @private\n *  @param {Object|Array} collection  A data object or an array, as the source.\n *  @param {Function} callback  A function to be executed on each iteration,\n *  with the following arguments: `(levelNotation, note, value, collection)`\n *  @param {Boolean} [reverseIfArray=false]  Set to `true` to iterate with\n *  `eachRight` to prevent shifted indexes when removing items from arrays.\n *  @param {Boolean} [byLevel=false]  Indicates whether to iterate notations by\n *  each level or by the end value.  For example, if we have a collection of\n *  `{a: { b: true } }`, and `byLevel` is set; the callback will be invoked on\n *  the following notations: `a`, `a.b`. Otherwise, it will be invoked only on\n *  `a.b`.\n *  @param {String} [parentNotation]  Storage for parent (previous) notation.\n *  @param {Collection} [topSource]  Storage for initial/main collection.\n *  @returns {void}\n */\nfunction _each(collection, callback, reverseIfArray = false, byLevel = false, parentNotation = null, topSource = null) { // eslint-disable-line max-params\n    const source = topSource || collection;\n    // if (!utils.isCollection(collection)) throw ... // no need\n    utils.eachItem(collection, (value, keyOrIndex) => {\n        const note = typeof keyOrIndex === 'number'\n            ? `[${keyOrIndex}]`\n            : keyOrIndex;\n        const currentNotation = Notation.join([parentNotation, note]);\n        const isCollection = utils.isCollection(value);\n        // if it's not a collection we'll execute the callback. if it's a\n        // collection but byLevel is set, we'll also execute the callback.\n        if (!isCollection || byLevel) {\n            if (callback(currentNotation, note, value, source) === false) return false;\n        }\n        // deep iterating if collection\n        if (isCollection) _each(value, callback, reverseIfArray, byLevel, currentNotation, source);\n    }, null, reverseIfArray);\n}\n\n// --------------------------------\n// EXPORT\n// --------------------------------\n\nexport { Notation };\n"],"sourceRoot":""}