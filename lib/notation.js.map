{"version":3,"sources":["webpack://notation/webpack/universalModuleDefinition","webpack://notation/webpack/bootstrap","webpack://notation/./src/core/notation.error.js","webpack://notation/./src/core/notation.glob.js","webpack://notation/./src/core/notation.js","webpack://notation/./src/index.js","webpack://notation/./src/utils.js"],"names":["setProto","Object","setPrototypeOf","NotationError","message","prototype","defineProperty","enumerable","writable","value","Error","hasOwnProperty","captureStackTrace","stack","reMATCHER","reVALIDATOR","RegExp","re","utils","ERR_INVALID","Glob","glob","ins","_inspect","notes","split","absGlob","_","parent","undefined","regexp","notation","Notation","isValid","_covers","restrictive","_intersect","isNegated","toRegExp","length","slice","last","replace","test","WILDCARDS","g","indexOf","pregQuote","globA","globB","match","a","b","notesA","notesB","covers","fn","_matchesNote","_coversNote","i","bang","len","Math","max","notesI","push","WILDCARD","joinNotes","trim","removeTrailingWildcards","isArrayGlob","normalize","neg","aIdxCompare","_compareArrayItemGlobs","wildCountA","wildCountB","globList","sort","compare","original","ensureArray","list","concat","_negFirstSort","_negLastSort","map","negateAll","normalized","ignored","intersections","checkAddIntersection","gA","gB","inter","hasInverted","_invert","eachRight","indexA","NEGATE_ALL","duplicate","hasExactNeg","negCoversPos","negCoveredByPos","negCoveredByNeg","posCoversPos","posCoveredByNeg","posCoveredByPos","indexB","JSON","stringify","splice","_isReverseOf","coversB","coveredByB","keepNeg","keepPos","keep","keys","globsListA","globsListB","union","notCovered","hasExact","negCoversNeg","posCoversNeg","globsA","globsB","_compareUnion","listA","listB","bIsArr","ARRAY_GLOB_NOTE","normalizeNote","_idxVal","note","parseInt","_compArrIdx","lastA","lastB","iA","iB","reANote","_rx","ERR","SOURCE","DEST","NOTATION","NOTA_OBJ","NO_INDEX","NO_PROP","DEFAULT_OPTS","freeze","strict","preserveIndices","source","options","arguments","_source","isCollection","_isArray","type","callback","_each","level","eachNote","levelNotation","index","hasOwn","each","cloneDeep","o","key","create","merge","expand","result","has","lastNoteNormalized","lastNote","parentIsArray","parentNotation","get","inspectGet","defaultValue","msg","mode","currentIsLast","nCurrentNote","nNextNote","nextIsArrayNote","insertErrMsg","notationsObject","overwrite","set","notations","inspectRemove","globs","empty","cloned","firstIsWildcard","filtered","shift","globNotation","levels","emptyValue","eType","errGlobIntegrity","insRemove","vType","errMsg","isValSet","isset","setMode","insGet","reverseIterateIfArray","originalNotation","originalIsCovered","levelLen","remove","destination","newNotation","newN","getNewNotation","target","moveTo","rename","copyTo","extract","extrude","_options","countNotes","levelNotes","join","collection","reverseIfArray","byLevel","topSource","eachItem","keyOrIndex","currentNotation","objProto","symValueOf","Symbol","valueOf","VAR","ARRAY_NOTE","OBJECT_BRACKETS","NON_NEG_WILDCARD_TRAIL","_reFlags","toString","call","toLowerCase","t","_collectionType","isArr","Date","flags","exec","copy","constructor","lastIndex","forEach","k","array","thisArg","apply","eachProp","object","str","String","stringOrArrayOf","hasSingleItemOf","arr","itemValue","m","current","next","dot"],"mappings":"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","file":"notation.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"notation\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"notation\"] = factory();\n\telse\n\t\troot[\"notation\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"lib/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","/* eslint consistent-this:0, no-prototype-builtins:0 */\n\nconst setProto = Object.setPrototypeOf;\n\n/**\n *  Error class specific to `Notation`.\n *  @class\n *  @name Notation.Error\n */\nclass NotationError extends Error {\n\n    /**\n     *  Initializes a new `Notation.Error` instance.\n     *  @hideconstructor\n     *  @constructs Notation.Error\n     *  @param {String} message - The error message.\n     */\n    constructor(message = '') {\n        super(message);\n        setProto(this, NotationError.prototype);\n\n        Object.defineProperty(this, 'name', {\n            enumerable: false,\n            writable: false,\n            value: 'NotationError'\n        });\n\n        Object.defineProperty(this, 'message', {\n            enumerable: false,\n            writable: true,\n            value: message\n        });\n\n        /* istanbul ignore else */\n        if (Error.hasOwnProperty('captureStackTrace')) { // V8\n            Error.captureStackTrace(this, NotationError);\n        } else {\n            Object.defineProperty(this, 'stack', {\n                enumerable: false,\n                writable: false,\n                value: (new Error(message)).stack\n            });\n        }\n    }\n\n}\n\nexport { NotationError };\n","/* eslint no-use-before-define:0, consistent-return:0, max-statements:0 */\n\nimport { Notation } from './notation';\nimport { NotationError } from './notation.error';\nimport { utils } from '../utils';\n\n// http://www.linfo.org/wildcard.html\n// http://en.wikipedia.org/wiki/Glob_%28programming%29\n// http://en.wikipedia.org/wiki/Wildcard_character#Computing\n\n// created test @ https://regex101.com/r/U08luj/2\nconst reMATCHER = /(\\[(\\d+|\\*|\".*\"|'.*')\\]|[a-z$_][a-z$_\\d]*|\\*)/gi; // ! negation should be removed first\n// created test @ https://regex101.com/r/mC8unE/3\n// /^!?(\\*|[a-z$_][a-z$_\\d]*|\\[(\\d+|\".*\"|'.*'|`.*`|\\*)\\])(\\[(\\d+|\".*\"|'.*'|`.*`|\\*)\\]|\\.[a-z$_][a-z$_\\d]*|\\.\\*)*$/i\nconst reVALIDATOR = new RegExp(\n    '^'\n    + '!?('                             // optional negation, only in the front\n    + '\\\\*'                             // wildcard star\n    + '|'                               // OR\n    + '[a-z$_][a-z$_\\\\d]*'              // JS variable syntax\n    + '|'                               // OR\n    + '\\\\[(\\\\d+|\\\\*|\".*\"|\\'.*\\')\\\\]'    // array index or wildcard, or object bracket notation\n    + ')'                               // exactly once\n    + '('\n    + '\\\\[(\\\\d+|\\\\*|\".*\"|\\'.*\\')\\\\]'    // followed by same\n    + '|'                               // OR\n    + '\\\\.[a-z$_][a-z$_\\\\d]*'           // dot, then JS variable syntax\n    + '|'                               // OR\n    + '\\\\.\\\\*'                          // dot, then wildcard star\n    + ')*'                              // (both) may repeat any number of times\n    + '$'\n    , 'i'\n);\n\nconst { re } = utils;\nconst ERR_INVALID = 'Invalid glob notation: ';\n\n/**\n *  `Notation.Glob` is a utility for validating, comparing and sorting\n *  dot-notation globs.\n *\n *  You can use {@link http://www.linfo.org/wildcard.html|wildcard} stars `*`\n *  and negate the notation by prepending a bang `!`. A star will include all\n *  the properties at that level and a negated notation will be excluded.\n *  @name Glob\n *  @memberof Notation\n *  @class\n *\n *  @example\n *  // for the following object;\n *  { name: 'John', billing: { account: { id: 1, active: true } } };\n *\n *  'billing.account.*'  // represents value `{ id: 1, active: true }`\n *  'billing.account.id' // represents value `1`\n *  '!billing.account.*' // represents value `{ name: 'John' }`\n *  'name' // represents `'John'`\n *  '*' // represents the whole object\n *\n *  @example\n *  var glob = new Notation.Glob('billing.account.*');\n *  glob.test('billing.account.id'); // true\n */\nclass Glob {\n\n    /**\n     *  Constructs a `Notation.Glob` object with the given glob string.\n     *  @constructs Notation.Glob\n     *  @param {String} glob - Notation string with globs.\n     *\n     *  @throws {NotationError} - If given notation glob is invalid.\n     */\n    constructor(glob) {\n        const ins = Glob._inspect(glob);\n        const notes = Glob.split(ins.absGlob);\n        this._ = {\n            ...ins,\n            notes,\n            // below props will be set at first getter call\n            parent: undefined, // don't set to null\n            regexp: undefined\n        };\n    }\n\n    // --------------------------------\n    // INSTANCE PROPERTIES\n    // --------------------------------\n\n    /**\n     *  Gets the normalized glob notation string.\n     *  @name Notation.Glob#glob\n     *  @type {String}\n     */\n    get glob() {\n        return this._.glob;\n    }\n\n    /**\n     *  Gets the absolute glob notation without the negation prefix `!` and\n     *  redundant trailing wildcards.\n     *  @name Notation.Glob#absGlob\n     *  @type {String}\n     */\n    get absGlob() {\n        return this._.absGlob;\n    }\n\n    /**\n     *  Specifies whether this glob is negated with a `!` prefix.\n     *  @name Notation.Glob#isNegated\n     *  @type {Boolean}\n     */\n    get isNegated() {\n        return this._.isNegated;\n    }\n\n    /**\n     *  Represents this glob in regular expressions.\n     *  Note that the negation prefix (`!`) is ignored, if any.\n     *  @name Notation.Glob#regexp\n     *  @type {RegExp}\n     */\n    get regexp() {\n        // setting on first call instead of in constructor, for performance\n        // optimization.\n        this._.regexp = this._.regexp || Glob.toRegExp(this.absGlob);\n        return this._.regexp;\n    }\n\n    /**\n     *  List of notes (levels) of this glob notation. Note that trailing,\n     *  redundant wildcards are removed from the original glob notation.\n     *  @name Notation.Glob#notes\n     *  @alias Notation.Glob#levels\n     *  @type {Array}\n     */\n    get notes() {\n        return this._.notes;\n    }\n\n    /**\n     *  Alias of `Notation.Glob#notes`.\n     *  @private\n     *  @name Notation.Glob#notes\n     *  @alias Notation.Glob#levels\n     *  @type {Array}\n     */\n    get levels() {\n        return this._.notes;\n    }\n\n    /**\n     *  Gets the first note of this glob notation.\n     *  @name Notation.Glob#first\n     *  @type {String}\n     */\n    get first() {\n        return this.notes[0];\n    }\n\n    /**\n     *  Gets the last note of this glob notation.\n     *  @name Notation.Glob#last\n     *  @type {String}\n     */\n    get last() {\n        return this.notes[this.notes.length - 1];\n    }\n\n    /**\n     *  Gets the parent notation (up to but excluding the last note) from the\n     *  glob notation string. Note that initially, trailing/redundant wildcards\n     *  are removed.\n     *  @name Notation.Glob#parent\n     *  @type {String}\n     *\n     *  @example\n     *  const glob = Notation.Glob.create;\n     *  glob('first.second.*').parent;   // \"first.second\"\n     *  glob('*.x.*').parent;            // \"*\" (\"*.x.*\" normalizes to \"*.x\")\n     *  glob('*').parent;                // null (no parent)\n     */\n    get parent() {\n        // setting on first call instead of in constructor, for performance\n        // optimization.\n        if (this._.parent === undefined) {\n            this._.parent = this.notes.length > 1\n                ? this.absGlob.slice(0, -this.last.length).replace(/\\.$/, '')\n                : null;\n        }\n        return this._.parent;\n    }\n\n    // --------------------------------\n    // INSTANCE METHODS\n    // --------------------------------\n\n    /**\n     *  Checks whether the given notation value matches the source notation\n     *  glob.\n     *  @name Notation.Glob#test\n     *  @function\n     *  @param {String} notation - The notation string to be tested. Cannot have\n     *  any globs.\n     *  @returns {Boolean} -\n     *  @throws {NotationError} - If given `notation` is not valid or contains\n     *  any globs.\n     *\n     *  @example\n     *  const glob = new Notation.Glob('!prop.*.name');\n     *  glob.test(\"prop.account.name\"); // true\n     */\n    test(notation) {\n        if (!Notation.isValid(notation)) {\n            throw new NotationError(`Invalid notation: '${notation}'`);\n        }\n        // return this.regexp.test(notation);\n        return Glob._covers(this, notation);\n    }\n\n    /**\n     *  Specifies whether this glob notation can represent (or cover) the given\n     *  glob notation. Note that negation prefix is ignored, if any.\n     *  @name Notation.Glob#covers\n     *  @function\n     *\n     *  @param {String|Array|Glob} glob  Glob notation string, glob\n     *  notes array or a `Notation.Glob` instance.\n     *  @returns {Boolean} -\n     *\n     *  @example\n     *  const glob = Notation.Glob.create;\n     *  glob('*.y').covers('x.y')      // true\n     *  glob('x[*].y').covers('x[*]')  // false\n     */\n    covers(glob) {\n        return Glob._covers(this, glob);\n    }\n\n    /**\n     *  Gets the intersection of this and the given glob notations. When\n     *  restrictive, if any one of them is negated, the outcome is negated.\n     *  Otherwise, only if both of them are negated, the outcome is negated.\n     *  @name Notation.Glob#intersect\n     *  @function\n     *\n     *  @param {String} glob - Second glob to be used.\n     *  @param {Boolean} [restrictive=false] - Whether the intersection should\n     *  be negated when one of the globs is negated.\n     *  @returns {String} - Intersection notation if any; otherwise `null`.\n     *\n     *  @example\n     *  const glob = Notation.Glob.create;\n     *  glob('x.*').intersect('!*.y')         // 'x.y'\n     *  glob('x.*').intersect('!*.y', true)   // '!x.y'\n     */\n    intersect(glob, restrictive = false) {\n        return Glob._intersect(this.glob, glob, restrictive);\n    }\n\n    // --------------------------------\n    // STATIC MEMBERS\n    // --------------------------------\n\n    /**\n     *  Basically constructs a new `Notation.Glob` instance\n     *  with the given glob string.\n     *  @name Notation.Glob.create\n     *  @function\n     *\n     *  @param {String} glob - The source notation glob.\n     *  @returns {Glob} -\n     *\n     *  @example\n     *  const glob = Notation.Glob.create(strGlob);\n     *  // equivalent to:\n     *  const glob = new Notation.Glob(strGlob);\n     */\n    static create(glob) {\n        return new Glob(glob);\n    }\n\n    // Created test at: https://regex101.com/r/tJ7yI9/4\n    /**\n     *  Validates the given notation glob.\n     *  @name Notation.Glob.isValid\n     *  @function\n     *\n     *  @param {String} glob - Notation glob to be validated.\n     *  @returns {Boolean} -\n     */\n    static isValid(glob) {\n        return typeof glob === 'string' && reVALIDATOR.test(glob);\n    }\n\n    /**\n     *  Specifies whether the given glob notation includes any valid wildcards\n     *  (`*`) or negation bang prefix (`!`).\n     *  @name Notation.Glob.hasMagic\n     *  @function\n     *\n     *  @param {String} glob - Glob notation to be checked.\n     *  @returns {Boolean} -\n     */\n    static hasMagic(glob) {\n        return Glob.isValid(glob) && (re.WILDCARDS.test(glob) || glob[0] === '!');\n    }\n\n    /**\n     *  Gets a regular expressions instance from the given glob notation.\n     *  Note that the bang `!` prefix will be ignored if the given glob is negated.\n     *  @name Notation.Glob.toRegExp\n     *  @function\n     *\n     *  @param {String} glob - Glob notation to be converted.\n     *\n     *  @returns {RegExp} - A `RegExp` instance from the glob.\n     *\n     *  @throws {NotationError} - If given notation glob is invalid.\n     */\n    static toRegExp(glob) {\n        if (!Glob.isValid(glob)) {\n            throw new NotationError(`${ERR_INVALID} '${glob}'`);\n        }\n\n        let g = glob.indexOf('!') === 0 ? glob.slice(1) : glob;\n        g = utils.pregQuote(g)\n            // `[*]` always represents array index e.g. `[1]`. so we'd replace\n            // `\\[\\*\\]` with `\\[\\d+\\]` but we should also watch for quotes: e.g.\n            // `[\"x[*]y\"]`\n            .replace(/\\\\\\[\\\\\\*\\\\\\](?=(?:[^\"]|\"[^\"]*\")*$)(?=(?:[^']|'[^']*')*$)/g, '\\\\[\\\\d+\\\\]')\n            // `*` within quotes (e.g. ['*']) is non-wildcard, just a regular star char.\n            // `*` outside of quotes is always JS variable syntax e.g. `prop.*`\n            .replace(/\\\\\\*(?=(?:[^\"]|\"[^\"]*\")*$)(?=(?:[^']|'[^']*')*$)/g, '[a-z$_][a-z$_\\\\d]*')\n            .replace(/\\\\\\?/g, '.');\n        return new RegExp('^' + g + '(?:[\\\\[\\\\.].+|$)', 'i');\n        // it should either end ($) or continue with a dot or bracket. So for\n        // example, `company.*` will produce `/^company\\.[a-z$_][a-z$_\\\\d]*(?:[\\\\[|\\\\.].+|$)/`\n        // which will match both `company.name` and `company.address.street` but\n        // will not match `some.company.name`. Also `!password` will not match\n        // `!password_reset`.\n    }\n\n    /**\n     *  Specifies whether first glob notation can represent (or cover) the\n     *  second.\n     *  @name Notation.Glob._covers\n     *  @function\n     *  @private\n     *\n     *  @param {String|Object|Glob} globA  Source glob notation string\n     *  or inspection result object or `Notation.Glob` instance.\n     *  @param {String|Object|Glob} globB  Glob notation string or\n     *  inspection result object or `Notation.Glob` instance.\n     *  @param {Boolean} [match=false]  Check whether notes match instead of\n     *  `globA` covers `globB`.\n     *  @returns {Boolean} -\n     *\n     *  @example\n     *  const { covers } = Notation.Glob;\n     *  covers('*.y', 'x.y')        // true\n     *  covers('x.y', '*.y')        // false\n     *  covers('x.y', '*.y', true)  // true\n     *  covers('x[*].y', 'x[*]')    // false\n     */\n    static _covers(globA, globB, match = false) {\n        const a = typeof globA === 'string'\n            ? new Glob(globA)\n            : globA; // assume (globA instanceof Notation.Glob || utils.type(globA) === 'object')\n\n        const b = typeof globB === 'string'\n            ? new Glob(globB)\n            : globB;\n\n        const notesA = a.notes || Glob.split(a.absGlob);\n        const notesB = b.notes || Glob.split(b.absGlob);\n\n        if (!match) {\n            // !x.*.* does not cover !x.* or x.* bec. !x.*.* ≠ x.* ≠ x\n            // x.*.* covers x.* bec. x.*.* = x.* = x\n            if (a.isNegated && notesA.length > notesB.length) return false;\n        }\n\n        let covers = true;\n        const fn = match ? _matchesNote : _coversNote;\n        for (let i = 0; i < notesA.length; i++) {\n            if (!fn(notesA[i], notesB[i])) {\n                covers = false;\n                break;\n            }\n        }\n        return covers;\n    }\n\n    /**\n     *  Gets the intersection notation of two glob notations. When restrictive,\n     *  if any one of them is negated, the outcome is negated. Otherwise, only\n     *  if both of them are negated, the outcome is negated.\n     *  @name Notation.Glob._intersect\n     *  @function\n     *  @private\n     *\n     *  @param {String} globA - First glob to be used.\n     *  @param {String} globB - Second glob to be used.\n     *  @param {Boolean} [restrictive=false] - Whether the intersection should\n     *  be negated when one of the globs is negated.\n     *  @returns {String} - Intersection notation if any; otherwise `null`.\n     *  @example\n     *  _intersect('!*.y', 'x.*', false)     // 'x.y'\n     *  _intersect('!*.y', 'x.*', true)      // '!x.y'\n     */\n    static _intersect(globA, globB, restrictive = false) {\n        // const bang = restrictive\n        //     ? (globA[0] === '!' || globB[0] === '!' ? '!' : '')\n        //     : (globA[0] === '!' && globB[0] === '!' ? '!' : '');\n\n        const notesA = Glob.split(globA, true);\n        const notesB = Glob.split(globB, true);\n\n        let bang;\n        if (restrictive) {\n            bang = globA[0] === '!' || globB[0] === '!' ? '!' : '';\n        } else {\n            if (globA[0] === '!' && globB[0] === '!') {\n                bang = '!';\n            } else {\n                bang = ((notesA.length > notesB.length && globA[0] === '!')\n                        || (notesB.length > notesA.length && globB[0] === '!'))\n                    ? '!'\n                    : '';\n            }\n        }\n\n        const len = Math.max(notesA.length, notesB.length);\n        let notesI = [];\n        let a, b;\n        //   x.*  ∩  *.y   »  x.y\n        // x.*.*  ∩  *.y   »  x.y.*\n        // x.*.z  ∩  *.y   »  x.y.z\n        //   x.y  ∩  *.b   »  (n/a)\n        //   x.y  ∩  a.*   »  (n/a)\n        for (let i = 0; i < len; i++) {\n            a = notesA[i];\n            b = notesB[i];\n            if (a === b) {\n                notesI.push(a);\n            } else if (a && re.WILDCARD.test(a)) {\n                if (!b) {\n                    notesI.push(a);\n                } else {\n                    notesI.push(b);\n                }\n            } else if (b && re.WILDCARD.test(b)) {\n                if (!a) {\n                    notesI.push(b);\n                } else {\n                    notesI.push(a);\n                }\n            } else if (a && !b) {\n                notesI.push(a);\n            } else if (!a && b) {\n                notesI.push(b);\n            } else { // if (a !== b) {\n                notesI = [];\n                break;\n            }\n        }\n\n        if (notesI.length > 0) return bang + utils.joinNotes(notesI);\n        return null;\n    }\n\n    /**\n     *  Undocumented.\n     *  @name Notation.Glob._inspect\n     *  @function\n     *  @private\n     *\n     *  @param {String} glob -\n     *  @returns {Object} -\n     */\n    static _inspect(glob) {\n        let g = glob.trim();\n        if (!Glob.isValid(g)) {\n            throw new NotationError(`${ERR_INVALID} '${glob}'`);\n        }\n        const isNegated = g[0] === '!';\n        // trailing wildcards are only redundant if not negated\n        if (!isNegated) g = utils.removeTrailingWildcards(g);\n        const absGlob = isNegated ? g.slice(1) : g;\n        return {\n            glob: g,\n            absGlob,\n            isNegated,\n            // e.g. [*] or [1] are array globs. [\"1\"] is not.\n            isArrayGlob: (/^\\[[^'\"]/).test(absGlob)\n        };\n    }\n\n    /**\n     *  Splits the given glob notation string into its notes (levels). Note that\n     *  this will exclude the `!` negation prefix, if it exists.\n     *  @name Notation.Glob.split\n     *  @function\n     *\n     *  @param {String} glob  Glob notation string to be splitted.\n     *  @param {String} [normalize=false]  Whether to remove trailing, redundant\n     *  wildcards.\n     *  @returns {Array} - A string array of glob notes (levels).\n     *  @throws {NotationError} - If given glob notation is invalid.\n     *\n     *  @example\n     *  Notation.Glob.split('*.list[2].prop')  // ['*', 'list', '[2]', 'prop']\n     *  // you can get the same result from the .notes property of a Notation.Glob instance.\n     */\n    static split(glob, normalize = false) {\n        if (!Glob.isValid(glob)) {\n            throw new NotationError(`${ERR_INVALID} '${glob}'`);\n        }\n        const neg = glob[0] === '!';\n        // trailing wildcards are redundant only when not negated\n        const g = !neg && normalize ? utils.removeTrailingWildcards(glob) : glob;\n        return g.replace(/^!/, '').match(reMATCHER);\n    }\n\n    /**\n     *  Compares two given notation globs and returns an integer value as a\n     *  result. This is generally used to sort glob arrays. Loose globs (with\n     *  stars especially closer to beginning of the glob string) and globs\n     *  representing the parent/root of the compared property glob come first.\n     *  Verbose/detailed/exact globs come last. (`* < *.abc < abc`).\n     *\n     *  For instance; `store.address` comes before `store.address.street`. So\n     *  this works both for `*, store.address.street, !store.address` and `*,\n     *  store.address, !store.address.street`. For cases such as `prop.id` vs\n     *  `!prop.id` which represent the same property; the negated glob comes\n     *  last.\n     *  @name Notation.Glob.compare\n     *  @function\n     *\n     *  @param {String} globA - First notation glob to be compared.\n     *  @param {String} globB - Second notation glob to be compared.\n     *\n     *  @returns {Number} - Returns `-1` if `globA` comes first, `1` if `globB`\n     *  comes first and `0` if equivalent priority.\n     *\n     *  @throws {NotationError} - If either `globA` or `globB` is invalid glob\n     *  notation.\n     *\n     *  @example\n     *  const { compare } = Notation.Glob;\n     *  compare('*', 'info.user')               // -1\n     *  compare('*', '[*]')                     // 0\n     *  compare('info.*.name', 'info.user')     // 1\n     */\n    static compare(globA, globB) {\n        // trivial case, both are exactly the same!\n        // or both are wildcard e.g. `*` or `[*]`\n        if (globA === globB || (re.WILDCARD.test(globA) && re.WILDCARD.test(globB))) return 0;\n\n        const a = new Glob(globA);\n        const b = new Glob(globB);\n\n        // Check depth (number of levels)\n        if (a.notes.length === b.notes.length) {\n            // check and compare if these are globs that represent items in the\n            // \"same\" array. if not, this will return 0.\n            const aIdxCompare = _compareArrayItemGlobs(a, b);\n            // we'll only continue comparing if 0 is returned\n            if (aIdxCompare !== 0) return aIdxCompare;\n\n            // count wildcards\n            const wildCountA = (a.absGlob.match(re.WILDCARDS) || []).length;\n            const wildCountB = (b.absGlob.match(re.WILDCARDS) || []).length;\n            if (wildCountA === wildCountB) {\n                // check for negation\n                if (!a.isNegated && b.isNegated) return -1;\n                if (a.isNegated && !b.isNegated) return 1;\n                // both are negated or neither are, return alphabetical\n                return a.absGlob < b.absGlob ? -1 : (a.absGlob > b.absGlob ? 1 : 0);\n            }\n            return wildCountA > wildCountB ? -1 : 1;\n        }\n\n        return a.notes.length < b.notes.length ? -1 : 1;\n    }\n\n    /**\n     *  Sorts the notation globs in the given array by their priorities. Loose\n     *  globs (with stars especially closer to beginning of the glob string);\n     *  globs representing the parent/root of the compared property glob come\n     *  first. Verbose/detailed/exact globs come last. (`* < *.y < x.y`).\n     *\n     *  For instance; `store.address` comes before `store.address.street`. For\n     *  cases such as `prop.id` vs `!prop.id` which represent the same property;\n     *  the negated glob wins (comes last).\n     *  @name Notation.Glob.sort\n     *  @function\n     *\n     *  @param {Array} globList - The notation globs array to be sorted. The\n     *  passed array reference is modified.\n     *  @returns {Array} - Logically sorted globs array.\n     *\n     *  @example\n     *  Notation.Glob.sort(['!prop.*.name', 'prop.*', 'prop.id']) // ['prop.*', 'prop.id', '!prop.*.name'];\n     */\n    static sort(globList) {\n        return globList.sort(Glob.compare);\n    }\n\n    /**\n     *  Normalizes the given notation globs array by removing duplicate or\n     *  redundant items, eliminating extra verbosity (also with intersection\n     *  globs) and returns a priority-sorted globs array.\n     *\n     *  <ul>\n     *  <li>If any exact duplicates found, all except first is removed.\n     *  <br />example: `['car', 'dog', 'car']` normalizes to `['car', 'dog']`.</li>\n     *  <li>If both normal and negated versions of a glob are found, negated wins.\n     *  <br />example: `['*', 'id', '!id']` normalizes to `['*', '!id']`.</li>\n     *  <li>If a glob is covered by another, it's removed.\n     *  <br />example: `['car.*', 'car.model']` normalizes to `['car']`.</li>\n     *  <li>If a negated glob is covered by another glob, it's kept.\n     *  <br />example: `['*', 'car', '!car.model']` normalizes as is.</li>\n     *  <li>If a negated glob is not covered by another or it does not cover any other;\n     *  then we check for for intersection glob. If found, adds them to list;\n     *  removes the original negated.\n     *  <br />example: `['car.*', '!*.model']` normalizes as to `['car', '!car.model']`.</li>\n     *  <li>In restrictive mode; if a glob is covered by another negated glob, it's removed.\n     *  Otherwise, it's kept.\n     *  <br />example: `['*', '!car.*', 'car.model']` normalizes to `['*', '!car']` if restrictive.</li>\n     *  </ul>\n     *  @name Notation.Glob.normalize\n     *  @function\n     *\n     *  @param {Array} globList - Notation globs array to be normalized.\n     *  @param {Boolean} [restrictive=false] - Whether negated items strictly\n     *  remove every match. Note that, regardless of this option, if any item has an\n     *  exact negated version; non-negated is always removed.\n     *  @returns {Array} -\n     *\n     *  @throws {NotationError} - If any item in globs list is invalid.\n     *\n     *  @example\n     *  const { normalize } = Notation.Glob;\n     *  normalize(['*', '!id', 'name', '!car.model', 'car.*', 'id', 'name']); // ['*', '!id', '!car.model']\n     *  normalize(['!*.id', 'user.*', 'company']); // ['company', 'user', '!company.id', '!user.id']\n     *  normalize(['*', 'car.model', '!car.*']); // [\"*\", \"!car.*\", \"car.model\"]\n     *  // restrictive normalize:\n     *  normalize(['*', 'car.model', '!car.*'], true); // [\"*\", \"!car.*\"]\n     */\n    static normalize(globList, restrictive = false) {\n        const { _inspect, _covers, _intersect } = Glob;\n\n        const original = utils.ensureArray(globList);\n        if (original.length === 0) return [];\n\n        const list = original\n            // prevent mutation\n            .concat()\n            // move negated globs to top so that we inspect non-negated globs\n            // against others first. when complete, we'll sort with our\n            // .compare() function.\n            .sort(restrictive ? _negFirstSort : _negLastSort)\n            // turning string array into inspect-obj array, so that we'll not\n            // run _inspect multiple times in the inner loop. this also\n            // pre-validates each glob.\n            .map(_inspect);\n\n        // early return if we have a single item\n        if (list.length === 1) {\n            const g = list[0];\n            // single negated item is redundant\n            if (g.isNegated) return [];\n            // return normalized\n            return [g.glob];\n        }\n\n        // flag to return an empty array (in restrictive mode), if true.\n        let negateAll = false;\n\n        // we'll push keepers in this array\n        let normalized = [];\n        // we'll need to remember excluded globs, so that we can move to next\n        // item early.\n        const ignored = {};\n\n        // storage to keep intersections.\n        // using an object to prevent duplicates.\n        let intersections = {};\n\n        const checkAddIntersection = (gA, gB) => {\n            const inter = _intersect(gA, gB, restrictive);\n            if (!inter) return;\n            // if the intersection result has an inverted version in the\n            // original list, don't add this.\n            const hasInverted = restrictive ? false : original.indexOf(_invert(inter)) >= 0;\n            // also if intersection result is in the current list, don't add it.\n            if (list.indexOf(inter) >= 0 || hasInverted) return;\n            intersections[inter] = inter;\n        };\n\n        // iterate each glob by comparing it to remaining globs.\n        utils.eachRight(list, (a, indexA) => {\n\n            // if `strict` is enabled, return empty if a negate-all is found\n            // (which itself is also redundant if single): '!*' or '![*]'\n            if (re.NEGATE_ALL.test(a.glob)) {\n                negateAll = true;\n                if (restrictive) return false;\n            }\n\n            // flags\n            let duplicate = false;\n            let hasExactNeg = false;\n            // flags for negated\n            let negCoversPos = false;\n            let negCoveredByPos = false;\n            let negCoveredByNeg = false;\n            // flags for non-negated (positive)\n            let posCoversPos = false;\n            let posCoveredByNeg = false;\n            let posCoveredByPos = false;\n\n            utils.eachRight(list, (b, indexB) => {\n                // don't inspect glob with itself\n                if (indexA === indexB) return; // move to next\n                // console.log(indexA, a.glob, 'vs', b.glob);\n\n                if (a.isArrayGlob !== b.isArrayGlob) {\n                    throw new NotationError(`Integrity failed. Cannot have both object and array notations for root level: ${JSON.stringify(original)}`);\n                }\n\n                // remove if duplicate\n                if (a.glob === b.glob) {\n                    list.splice(indexA, 1);\n                    duplicate = true;\n                    return false; // break out\n                }\n\n                // remove if positive has an exact negated (negated wins when\n                // normalized) e.g. ['*', 'a', '!a'] => ['*', '!a']\n                if (!a.isNegated && _isReverseOf(a, b)) {\n                    // list.splice(indexA, 1);\n                    ignored[a.glob] = true;\n                    hasExactNeg = true;\n                    return false; // break out\n                }\n\n                // if already excluded b, go on to next\n                if (ignored[b.glob]) return; // next\n\n                const coversB = _covers(a, b);\n                const coveredByB = coversB ? false : _covers(b, a);\n                if (a.isNegated) {\n                    if (b.isNegated) {\n                        // if negated (a) covered by any other negated (b); remove (a)!\n                        if (coveredByB) {\n                            negCoveredByNeg = true;\n                            // list.splice(indexA, 1);\n                            ignored[a.glob] = true;\n                            return false; // break out\n                        }\n                    } else {\n                        /* istanbul ignore if */\n                        if (coversB) negCoversPos = true;\n                        if (coveredByB) negCoveredByPos = true;\n                        // try intersection if none covers the other and only\n                        // one of them is negated.\n                        if (!coversB && !coveredByB) {\n                            checkAddIntersection(a.glob, b.glob);\n                        }\n                    }\n                } else {\n                    if (b.isNegated) {\n                        // if positive (a) covered by any negated (b); remove (a)!\n                        if (coveredByB) {\n                            posCoveredByNeg = true;\n                            if (restrictive) {\n                                // list.splice(indexA, 1);\n                                ignored[a.glob] = true;\n                                return false; // break out\n                            }\n                            return; // next\n                        }\n                        // try intersection if none covers the other and only\n                        // one of them is negated.\n                        if (!coversB && !coveredByB) {\n                            checkAddIntersection(a.glob, b.glob);\n                        }\n                    } else {\n                        if (coversB) posCoversPos = coversB;\n                        // if positive (a) covered by any other positive (b); remove (a)!\n                        if (coveredByB) {\n                            posCoveredByPos = true;\n                            if (restrictive) {\n                                // list.splice(indexA, 1);\n                                return false; // break out\n                            }\n                        }\n                    }\n                }\n\n            });\n\n            // const keepNeg = (negCoversPos || negCoveredByPos) && !negCoveredByNeg;\n            const keepNeg = restrictive\n                ? (negCoversPos || negCoveredByPos) && negCoveredByNeg === false\n                : negCoveredByPos && negCoveredByNeg === false;\n            const keepPos = restrictive\n                ? (posCoversPos || posCoveredByPos === false) && posCoveredByNeg === false\n                : posCoveredByNeg || posCoveredByPos === false;\n            const keep = duplicate === false\n                && hasExactNeg === false\n                && (a.isNegated ? keepNeg : keepPos);\n\n            if (keep) {\n                normalized.push(a.glob);\n            } else {\n                // this is excluded from final (normalized) list, so mark as\n                // ignored (don't remove from \"list\" for now)\n                ignored[a.glob] = true;\n            }\n        });\n\n        if (restrictive && negateAll) return [];\n\n        intersections = Object.keys(intersections);\n        if (intersections.length > 0) {\n            // merge normalized list with intersections if any\n            normalized = normalized.concat(intersections);\n            // we have new (intersection) items, so re-normalize\n            return Glob.normalize(normalized, restrictive);\n        }\n\n        return Glob.sort(normalized);\n    }\n\n    /**\n     *  Undocumented. See `.union()`\n     *  @name Notation.Glob._compareUnion\n     *  @function\n     *  @private\n     *\n     *  @param {Array} globsListA -\n     *  @param {Array} globsListB -\n     *  @param {Boolean} restrictive -\n     *  @param {Array} union -\n     *  @returns {Array} -\n     */\n    static _compareUnion(globsListA, globsListB, restrictive, union = []) {\n        const { _covers } = Glob;\n\n        const { _inspect, _intersect } = Glob;\n\n        utils.eachRight(globsListA, globA => {\n            if (union.indexOf(globA) >= 0) return; // next\n\n            const a = _inspect(globA);\n\n            // if wildcard only, add...\n            if (re.WILDCARD.test(a.absGlob)) {\n                union.push(a.glob); // push normalized glob\n                return; // next\n            }\n\n            let notCovered = false;\n            let hasExact = false;\n            let negCoversNeg = false;\n            let posCoversNeg = false;\n            let posCoversPos = false;\n            let negCoversPos = false;\n\n            const intersections = [];\n\n            utils.eachRight(globsListB, globB => {\n\n                // keep if has exact in the other\n                if (globA === globB) hasExact = true;\n\n                const b = _inspect(globB);\n\n                // keep negated if:\n                //    1) any negated covers it\n                //    2) no positive covers it\n                // keep positive if:\n                //    1) no positive covers it OR any negated covers it\n\n                notCovered = !_covers(b, a);\n                if (notCovered) {\n                    if (a.isNegated && b.isNegated) {\n                        const inter = _intersect(a.glob, b.glob, restrictive);\n                        if (inter && union.indexOf(inter) === -1) intersections.push(inter);\n                    }\n                    return; // next\n                }\n\n                if (a.isNegated) {\n                    if (b.isNegated) {\n                        negCoversNeg = !hasExact;\n                    } else {\n                        posCoversNeg = true; // set flag\n                    }\n                } else {\n                    if (!b.isNegated) {\n                        posCoversPos = !hasExact;\n                    } else {\n                        negCoversPos = true; // set flag\n                    }\n                }\n\n            });\n\n\n            const keep = a.isNegated\n                ? (!posCoversNeg || negCoversNeg)\n                : (!posCoversPos || negCoversPos);\n\n            if (hasExact || keep || (notCovered && !a.isNegated)) {\n                union.push(a.glob); // push normalized glob\n                return;\n            }\n\n            if (a.isNegated && posCoversNeg && !negCoversNeg && intersections.length > 0) {\n                union = union.concat(intersections);\n            }\n\n        });\n\n        return union;\n    }\n\n    /**\n     *  Gets the union from the given couple of glob arrays and returns a new\n     *  array of globs.\n     *  <ul>\n     *  <li>If the exact same element is found in both\n     *  arrays, one of them is removed to prevent duplicates.\n     *  <br />example: `['!id', 'name'] ∪ ['!id']` unites to `['!id', 'name']`</li>\n     *  <li>If any non-negated item is covered by a glob in the same\n     *  or other array, the redundant item is removed.\n     *  <br />example: `['*', 'name'] ∪ ['email']` unites to `['*']`</li>\n     *  <li>If one of the arrays contains a negated equivalent of an\n     *  item in the other array, the negated item is removed.\n     *  <br />example: `['!id'] ∪ ['id']` unites to `['id']`</li>\n     *  <li>If any item covers/matches a negated item in the other array,\n     *  the negated item is removed.\n     *  <br />example #1: `['!user.id'] ∪ ['user.*']` unites to `['user']`\n     *  <br />example #2: `['*'] ∪ ['!password']` unites to `['*']`\n     *  </li>\n     *  </ul>\n     *  @name Notation.Glob.union\n     *  @function\n     *\n     *  @param {Array} globsA - First array of glob strings.\n     *  @param {Array} globsB - Second array of glob strings.\n     *  @param {Boolean} [restrictive=false] - Whether negated items in each of\n     *  the lists, strictly remove every match in themselves (not the cross\n     *  list). This option is used when pre-normalizing each glob list and\n     *  normalizing the final union list.\n     *\n     *  @returns {Array} -\n     *\n     *  @example\n     *  const a = ['user.*', '!user.email', 'car.model', '!*.id'];\n     *  const b = ['!*.date', 'user.email', 'car', '*.age'];\n     *  const { union } = Notation.Glob;\n     *  union(a, b)     // ['car', 'user', '*.age', '!car.date', '!user.id']\n     */\n    static union(globsA, globsB, restrictive) {\n        const { normalize, _compareUnion } = Glob;\n\n        const listA = normalize(globsA, restrictive);\n        const listB = normalize(globsB, restrictive);\n\n        if (listA.length === 0) return listB;\n        if (listB.length === 0) return listA;\n\n        // TODO: below should be optimized\n        let union = _compareUnion(listA, listB, restrictive);\n        union = _compareUnion(listB, listA, restrictive, union);\n        return normalize(union, restrictive);\n    }\n\n}\n\n// --------------------------------\n// HELPERS\n// --------------------------------\n\n// used by static _covers\nfunction _coversNote(a, b) {\n    if (!a || !b) return false; // glob e.g.: [2] does not cover [2][1]\n    const bIsArr = re.ARRAY_GLOB_NOTE.test(b);\n    // obj-wildcard a will cover b if not array\n    if (a === '*') return !bIsArr;\n    // arr-wildcard a will cover b if array\n    if (a === '[*]') return bIsArr;\n    // seems, a is not wildcard so,\n    // if b is wildcard (obj or arr) won't be covered\n    if (re.WILDCARD.test(b)) return false;\n    // normalize both and check for equality\n    // e.g. x.y and x['y'] are the same\n    return utils.normalizeNote(a) === utils.normalizeNote(b);\n}\n// function _coversNote(a, b) {\n//     if (!a || !b) return false; // glob e.g.: [2] does not cover [2][1]\n//     a = utils.normalizeNote(a, true);\n//     b = utils.normalizeNote(b, true);\n//     if (a === b) return true;\n//     const bIsArr = re.ARRAY_GLOB_NOTE.test(b);\n//     return (a === '*' && !bIsArr) || (a === '[*]' && bIsArr);\n// }\n// used by static _covers\nfunction _matchesNote(a, b) {\n    if (!a || !b) return true; // glob e.g.: [2][1] matches [2] and vice-versa.\n    return _coversNote(a, b) || _coversNote(b, a);\n}\n\n// used by _compareArrayItemGlobs() for getting a numeric index from array note.\n// we'll use these indexes to sort higher to lower, as removing order; to\n// prevent shifted indexes.\nfunction _idxVal(note) {\n    // we return -1 for wildcard bec. we need it to come last\n\n    // below will never execute when called from _compareArrayItemGlobs\n    /* istanbul ignore next */\n    // if (note === '[*]') return -1;\n\n    // e.g. '[2]' » 2\n    return parseInt(note.replace(/[[\\]]/, ''), 10);\n}\n\nfunction _compArrIdx(lastA, lastB) {\n    const iA = _idxVal(lastA);\n    const iB = _idxVal(lastB);\n\n    // below will never execute when called from _compareArrayItemGlobs\n    /* istanbul ignore next */\n    // if (iA === iB) return 0;\n\n    return iA > iB ? -1 : 1;\n}\n\n// when we remove items from an array (via e.g. filtering), we first need to\n// remove the item with the greater index so indexes of other items (that are to\n// be removed from the same array) do not shift. so below is for comparing 2\n// globs if they represent 2 items from the same array.\n\n// example items from same array: ![*][2] ![0][*] ![0][1] ![0][3]\n// should be sorted as ![0][3] ![*][2] ![0][1] ![0][*]\nfunction _compareArrayItemGlobs(a, b) {\n    const reANote = re.ARRAY_GLOB_NOTE;\n    // both should be negated\n    if (!a.isNegated\n            || !b.isNegated\n            // should be same length (since we're comparing for items in same\n            // array)\n            || a.notes.length !== b.notes.length\n            // last notes should be array brackets\n            || !reANote.test(a.last)\n            || !reANote.test(b.last)\n            // last notes should be different to compare\n            || a.last === b.last\n    ) return 0;\n\n    // negated !..[*] should come last\n    if (a.last === '[*]') return 1; // b is first\n    if (b.last === '[*]') return -1; // a is first\n\n    if (a.parent && b.parent) {\n        const { _covers } = Glob;\n        if (_covers(a.parent, b.parent, true)) {\n            return _compArrIdx(a.last, b.last);\n        }\n        return 0;\n    }\n    return _compArrIdx(a.last, b.last);\n}\n\n// x vs !x.*.*      » false\n// x vs !x[*]       » true\n// x[*] vs !x       » true\n// x[*] vs !x[*]    » false\n// x.* vs !x.*      » false\nfunction _isReverseOf(a, b) {\n    return a.isNegated !== b.isNegated\n        && a.absGlob === b.absGlob;\n}\n\nfunction _invert(glob) {\n    return glob[0] === '!' ? glob.slice(1) : '!' + glob;\n}\n\nconst _rx = /^\\s*!/;\nfunction _negFirstSort(a, b) {\n    return _rx.test(a) ? -1 : (_rx.test(b) ? 1 : 0);\n}\nfunction _negLastSort(a, b) {\n    return _rx.test(a) ? 1 : (_rx.test(b) ? -1 : 0);\n}\n\n// --------------------------------\n// EXPORT\n// --------------------------------\n\nexport { Glob };\n","/* eslint no-use-before-define:0, consistent-return:0, max-statements:0 */\n\nimport { Glob } from './notation.glob';\nimport { NotationError } from './notation.error';\nimport { utils } from '../utils';\n\nconst ERR = {\n    SOURCE: 'Invalid source. Expected a data object or array.',\n    DEST: 'Invalid destination. Expected a data object or array.',\n    NOTATION: 'Invalid notation: ',\n    NOTA_OBJ: 'Invalid notations object. ',\n    NO_INDEX: 'Implied index does not exist: ',\n    NO_PROP: 'Implied property does not exist: '\n};\n\n// created test @ https://regex101.com/r/vLE16M/2\nconst reMATCHER = /(\\[(\\d+|\".*\"|'.*'|`.*`)\\]|[a-z$_][a-z$_\\d]*)/gi;\n// created test @ https://regex101.com/r/fL3PJt/1/\n// /^([a-z$_][a-z$_\\d]*|\\[(\\d+|\".*\"|'.*'|`.*`)\\])(\\[(\\d+|\".*\"|'.*'|`.*`)\\]|(\\.[a-z$_][a-z$_\\d]*))*$/i\nconst reVALIDATOR = new RegExp(\n    '^('\n    + '[a-z$_][a-z$_\\\\d]*'          // JS variable syntax\n    + '|'                           // OR\n    + '\\\\[(\\\\d+|\".*\"|\\'.*\\')\\\\]'    // array index or object bracket notation\n    + ')'                           // exactly once\n    + '('\n    + '\\\\[(\\\\d+|\".*\"|\\'.*\\')\\\\]'    // followed by same\n    + '|'                           // OR\n    + '\\\\.[a-z$_][a-z$_\\\\d]*'       // dot, then JS variable syntax\n    + ')*'                          // (both) may repeat any number of times\n    + '$'\n    , 'i'\n);\n\nconst DEFAULT_OPTS = Object.freeze({\n    strict: false,\n    preserveIndices: false\n});\n\n/**\n *  Notation.js for Node and Browser.\n *\n *  Like in most programming languages, JavaScript makes use of dot-notation to\n *  access the value of a member of an object (or class). `Notation` class\n *  provides various methods for modifying / processing the contents of the\n *  given object; by parsing object notation strings or globs.\n *\n *  Note that this class will only deal with enumerable properties of the source\n *  object; so it should be used to manipulate data objects. It will not deal\n *  with preserving the prototype-chain of the given object.\n *\n *  @author   Onur Yıldırım <onur@cutepilot.com>\n *  @license  MIT\n */\nclass Notation {\n\n    /**\n     *  Initializes a new instance of `Notation`.\n     *\n     *  @param {Object|Array} [source={}] - The source object (or array) to be\n     *  notated. Can either be an array or object. If omitted, defaults to an\n     *  empty object.\n     *  @param {Object} [options] - Notation options.\n     *      @param {Boolean} [options.strict=false] - Whether to throw either when\n     *      a notation path does not exist on the source (i.e. `#get()` and `#remove()`\n     *      methods); or notation path exists but overwriting is disabled (i.e.\n     *      `#set()` method). (Note that `.inspectGet()` and `.inspectRemove()` methods\n     *      are exceptions). It's recommended to set this to `true` and prevent silent\n     *      failures if you're working with sensitive data. Regardless of `strict` option,\n     *      it will always throw on invalid notation syntax or other crucial failures.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  const notation = new Notation(obj);\n     *  notation.get('car.model')   // » \"Charger\"\n     *  notation.remove('car.model').set('car.color', 'red').value\n     *  // » { car: { brand: \"Dodge\", year: 1970, color: \"red\" } }\n     */\n    constructor(source, options) {\n        if (arguments.length === 0) {\n            this._source = {};\n        } else if (!utils.isCollection(source)) {\n            throw new NotationError(ERR.SOURCE);\n        } else {\n            this._source = source;\n        }\n\n        this._isArray = utils.type(this._source) === 'array';\n        this.options = options;\n    }\n\n    // --------------------------------\n    // INSTANCE PROPERTIES\n    // --------------------------------\n\n    /**\n     *  Gets or sets notation options.\n     *  @type {Object}\n     */\n    get options() {\n        return this._options;\n    }\n\n    set options(value) {\n        this._options = {\n            ...DEFAULT_OPTS,\n            ...(this._options || {}),\n            ...(value || {})\n        };\n    }\n\n    /**\n     *  Gets the value of the source object.\n     *  @type {Object|Array}\n     *\n     *  @example\n     *  const person = { name: \"Onur\" };\n     *  const me = Notation.create(person)\n     *      .set(\"age\", 36)\n     *      .set(\"car.brand\", \"Ford\")\n     *      .set(\"car.model\", \"Mustang\")\n     *      .value;\n     *  console.log(me); // { name: \"Onur\", age: 36, car: { brand: \"Ford\", model: \"Mustang\" } }\n     *  console.log(person === me); // true\n     */\n    get value() {\n        return this._source;\n    }\n\n    // --------------------------------\n    // INSTANCE METHODS\n    // --------------------------------\n\n    /**\n     *  Recursively iterates through each key of the source object and invokes\n     *  the given callback function with parameters, on each non-object value.\n     *\n     *  @param {Function} callback - The callback function to be invoked on\n     *  each on each non-object value. To break out of the loop, return `false`\n     *  from within the callback.\n     *  Callback signature: `callback(notation, key, value, object) { ... }`\n     *\n     *  @returns {Notation} - The current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  Notation.create(obj).each(function (notation, key, value, object) {\n     *      console.log(notation, value);\n     *  });\n     *  // \"car.brand\"  \"Dodge\"\n     *  // \"car.model\"  \"Charger\"\n     *  // \"car.year\"  1970\n     */\n    each(callback) {\n        _each(this._source, callback);\n        return this;\n    }\n\n    /**\n     *  Iterates through each note of the given notation string by evaluating\n     *  it on the source object.\n     *\n     *  @param {String} notation - The notation string to be iterated through.\n     *  @param {Function} callback - The callback function to be invoked on\n     *  each iteration. To break out of the loop, return `false` from within\n     *  the callback. Signature: `callback(levelValue, note, index, list)`\n     *\n     *  @returns {Notation} - The current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  Notation.create(obj)\n     *      .eachValue(\"car.brand\", function (levelValue, note, index, list) {\n     *          console.log(note, levelValue); // \"car.brand\" \"Dodge\"\n     *      });\n     */\n    eachValue(notation, callback) {\n        let level = this._source;\n        Notation.eachNote(notation, (levelNotation, note, index, list) => {\n            level = utils.hasOwn(level, note) ? level[note] : undefined;\n            if (callback(level, levelNotation, note, index, list) === false) return false;\n\n        });\n        return this;\n    }\n\n    /**\n     *  Gets the list of notations from the source object (keys).\n     *\n     *  @returns {Array} - An array of notation strings.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  const notations = Notation.create(obj).getNotations();\n     *  console.log(notations); // [ \"car.brand\", \"car.model\", \"car.year\" ]\n     */\n    getNotations() {\n        const list = [];\n        this.each(notation => {\n            list.push(notation);\n        });\n        return list;\n    }\n\n    /**\n     *  Deeply clones the source object. This is also useful if you want to\n     *  prevent mutating the original source object.\n     *\n     *  <blockquote>\n     *  Note that `Notation` expects a data object (or array) with enumerable\n     *  properties. In addition to plain objects and arrays; supported cloneable\n     *  property/value types are primitives (such as `String`, `Number`,\n     *  `Boolean`, `Symbol`, `null` and `undefined`) and built-in types (such as\n     *  `Date` and `RegExp`).\n     *\n     *  Enumerable properties with types other than these (such as methods,\n     *  special objects, custom class instances, etc) will be copied by reference.\n     *  Non-enumerable properties will not be cloned.\n     *\n     *  If you still need full clone support, you can use a library like lodash.\n     *  e.g. `Notation.create(_.cloneDeep(source))`\n     *  </blockquote>\n     *\n     *  @returns {Notation} - The current `Notation` instance (self).\n     *\n     *  @example\n     *  const mutated = Notation.create(source1).set('newProp', true).value;\n     *  console.log(source1.newProp); // ——» true\n     *\n     *  const cloned = Notation.create(source2).clone().set('newProp', true).value;\n     *  console.log('newProp' in source2); // ——» false\n     *  console.log(cloned.newProp); // ——» true\n     */\n    clone() {\n        this._source = utils.cloneDeep(this._source);\n        return this;\n    }\n\n    /**\n     *  Flattens the source object to a single-level object with notated keys.\n     *\n     *  @returns {Notation} - The current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  console.log(Notation.create(obj).flatten().value);\n     *  // {\n     *  //     \"car.brand\": \"Dodge\",\n     *  //     \"car.model\": \"Charger\",\n     *  //     \"car.year\": 1970\n     *  // }\n     */\n    flatten() {\n        const o = {};\n        this.each((notation, key, value) => {\n            o[notation] = value;\n        });\n        this._source = o;\n        return this;\n    }\n\n    /**\n     *  Aggregates notated keys of a (single-level) object, and nests them under\n     *  their corresponding properties. This is the opposite of `Notation#flatten`\n     *  method. This might be useful when expanding a flat object fetched from\n     *  a database.\n     *  @alias Notation#aggregate\n     *  @chainable\n     *\n     *  @returns {Notation} - The current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { \"car.brand\": \"Dodge\", \"car.model\": \"Charger\", \"car.year\": 1970 }\n     *  const expanded = Notation.create(obj).expand().value;\n     *  console.log(expanded); // { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     */\n    expand() {\n        this._source = Notation.create({}).merge(this._source).value;\n        return this;\n    }\n\n    /**\n     *  Alias for `#expand`\n     *  @private\n     *  @returns {Notation} -\n     */\n    aggregate() {\n        return this.expand();\n    }\n\n    /**\n     *  Inspects the given notation on the source object by checking\n     *  if the source object actually has the notated property;\n     *  and getting its value if exists.\n     *  @param {String} notation - The notation string to be inspected.\n     *  @returns {InspectResult} - The result object.\n     *\n     *  @example\n     *  Notation.create({ car: { year: 1970 } }).inspectGet(\"car.year\");\n     *  // { has: true, value: 1970, lastNote: 'year', lastNoteNormalized: 'year' }\n     *  Notation.create({ car: { year: 1970 } }).inspectGet(\"car.color\");\n     *  // { has: false }\n     *  Notation.create({ car: { color: undefined } }).inspectGet(\"car.color\");\n     *  // { has: true, value: undefined, lastNote: 'color', lastNoteNormalized: 'color' }\n     *  Notation.create({ car: { brands: ['Ford', 'Dodge'] } }).inspectGet(\"car.brands[1]\");\n     *  // { has: true, value: 'Dodge', lastNote: '[1]', lastNoteNormalized: 1 }\n     */\n    inspectGet(notation) {\n        let level = this._source;\n        let result = { has: false, value: undefined };\n        let parent;\n        Notation.eachNote(notation, (levelNotation, note, index) => {\n            const lastNoteNormalized = utils.normalizeNote(note);\n            if (utils.hasOwn(level, lastNoteNormalized)) {\n                level = level[lastNoteNormalized];\n                parent = level;\n                result = {\n                    notation,\n                    has: true,\n                    value: level,\n                    type: utils.type(level),\n                    level: index + 1,\n                    lastNote: note,\n                    lastNoteNormalized\n                };\n            } else {\n                // level = undefined;\n                result = {\n                    notation,\n                    has: false,\n                    type: 'undefined',\n                    level: index + 1,\n                    lastNote: note,\n                    lastNoteNormalized\n                };\n                return false; // break out\n            }\n        });\n\n        if (parent === undefined || (result.has && parent === result.value)) parent = this._source;\n        result.parentIsArray = utils.type(parent) === 'array';\n\n        return result;\n    }\n\n    /**\n     *  Notation inspection result object.\n     *  @typedef Notation~InspectResult\n     *  @type Object\n     *  @property {String} notation - Notation that is inspected.\n     *  @property {Boolean} has - Indicates whether the source object has the\n     *  given notation as a (leveled) enumerable property. If the property\n     *  exists but has a value of `undefined`, this will still return `true`.\n     *  @property {*} value - The value of the notated property. If the source\n     *  object does not have the notation, the value will be `undefined`.\n     *  @property {String} type - The type of the notated property. If the source\n     *  object does not have the notation, the type will be `\"undefined\"`.\n     *  @property {String} lastNote - Last note of the notation, if actually\n     *  exists. For example, last note of `'a.b.c'` is `'c'`.\n     *  @property {String|Number} lastNoteNormalized - Normalized representation\n     *  of the last note of the notation, if actually exists. For example, last\n     *  note of `'a.b[1]` is `'[1]'` and will be normalized to number `1`; which\n     *  indicates an array index.\n     *  @property {Boolean} parentIsArray - Whether the parent object of the\n     *  notation path is an array.\n     */\n\n    /**\n     *  Inspects and removes the given notation from the source object by\n     *  checking if the source object actually has the notated property; and\n     *  getting its value if exists, before removing the property.\n     *\n     *  @param {String} notation - The notation string to be inspected.\n     *\n     *  @returns {InspectResult} - The result object.\n     *\n     *  @example\n     *  const obj = { name: \"John\", car: { year: 1970 } };\n     *  let result = Notation.create(obj).inspectRemove(\"car.year\");\n     *  // result » { notation: \"car.year\", has: true, value: 1970, lastNote: \"year\", lastNoteNormalized: \"year\" }\n     *  // obj » { name: \"John\", car: {} }\n     *\n     *  result = Notation.create({ car: { year: 1970 } }).inspectRemove(\"car.color\");\n     *  // result » { notation: \"car.color\", has: false }\n     *  Notation.create({ car: { color: undefined } }).inspectRemove(\"car['color']\");\n     *  // { notation: \"car.color\", has: true, value: undefined, lastNote: \"['color']\", lastNoteNormalized: \"color\" }\n     *\n     *  const obj = { car: { colors: [\"black\", \"white\"] } };\n     *  const result = Notation.create().inspectRemove(\"car.colors[0]\");\n     *  // result » { notation: \"car.colors[0]\", has: true, value: \"black\", lastNote: \"[0]\", lastNoteNormalized: 0 }\n     *  // obj » { car: { colors: [(empty), \"white\"] } }\n     */\n    inspectRemove(notation) {\n        if (!notation) throw new Error(ERR.NOTATION + `'${notation}'`);\n        const parentNotation = Notation.parent(notation);\n        const parent = parentNotation ? this.get(parentNotation, null) : this._source;\n        const parentIsArray = utils.type(parent) === 'array';\n        const notes = Notation.split(notation);\n        const lastNote = notes[notes.length - 1];\n        const lastNoteNormalized = utils.normalizeNote(lastNote);\n\n        let result, value;\n        if (utils.hasOwn(parent, lastNoteNormalized)) {\n            value = parent[lastNoteNormalized];\n            result = {\n                notation,\n                has: true,\n                value,\n                type: utils.type(value),\n                level: notes.length,\n                lastNote,\n                lastNoteNormalized,\n                parentIsArray\n            };\n\n            // if `preserveIndices` is enabled and this is an array, we'll\n            // splice the item out. otherwise, we'll use `delete` syntax to\n            // empty the item.\n            if (!this.options.preserveIndices && parentIsArray) {\n                parent.splice(lastNoteNormalized, 1);\n            } else {\n                delete parent[lastNoteNormalized];\n            }\n        } else {\n            result = {\n                notation,\n                has: false,\n                type: 'undefined',\n                level: notes.length,\n                lastNote,\n                lastNoteNormalized,\n                parentIsArray\n            };\n        }\n\n        return result;\n    }\n\n    /**\n     *  Checks whether the source object has the given notation\n     *  as a (leveled) enumerable property. If the property exists\n     *  but has a value of `undefined`, this will still return `true`.\n     *  @param {String} notation - The notation string to be checked.\n     *  @returns {Boolean} -\n     *\n     *  @example\n     *  Notation.create({ car: { year: 1970 } }).has(\"car.year\"); // true\n     *  Notation.create({ car: { year: undefined } }).has(\"car.year\"); // true\n     *  Notation.create({}).has(\"car.color\"); // false\n     */\n    has(notation) {\n        return this.inspectGet(notation).has;\n    }\n\n    /**\n     *  Checks whether the source object has the given notation\n     *  as a (leveled) defined enumerable property. If the property\n     *  exists but has a value of `undefined`, this will return `false`.\n     *  @param {String} notation - The notation string to be checked.\n     *  @returns {Boolean} -\n     *\n     *  @example\n     *  Notation.create({ car: { year: 1970 } }).hasDefined(\"car.year\"); // true\n     *  Notation.create({ car: { year: undefined } }).hasDefined(\"car.year\"); // false\n     *  Notation.create({}).hasDefined(\"car.color\"); // false\n     */\n    hasDefined(notation) {\n        return this.inspectGet(notation).value !== undefined;\n    }\n\n    /**\n     *  Gets the value of the corresponding property at the given notation.\n     *\n     *  @param {String} notation - The notation string to be processed.\n     *  @param {String} [defaultValue] - The default value to be returned if the\n     *  property is not found or enumerable.\n     *\n     *  @returns {*} - The value of the notated property.\n     *  @throws {NotationError} - If `strict` option is enabled, `defaultValue`\n     *  is not set and notation does not exist.\n     *\n     *  @example\n     *  Notation.create({ car: { brand: \"Dodge\" } }).get(\"car.brand\"); // \"Dodge\"\n     *  Notation.create({ car: {} }).get(\"car.model\", \"Challenger\"); // \"Challenger\"\n     *  Notation.create({ car: { model: undefined } }).get(\"car.model\", \"Challenger\"); // undefined\n     *\n     *  @example <caption>get value when strict option is enabled</caption>\n     *  // strict option defaults to false\n     *  Notation.create({ car: {} }).get(\"car.model\"); // undefined\n     *  Notation.create({ car: {} }, { strict: false }).get(\"car.model\"); // undefined\n     *  // below will throw bec. strict = true, car.model does not exist\n     *  // and no default value is given.\n     *  Notation.create({ car: {} }, { strict: true }).get(\"car.model\");\n     */\n    get(notation, defaultValue) {\n        const result = this.inspectGet(notation);\n        // if strict and no default value is set, check if implied index or prop\n        // exists\n        if (this.options.strict && arguments.length < 2 && !result.has) {\n            const msg = result.parentIsArray ? ERR.NO_INDEX : ERR.NO_PROP;\n            throw new NotationError(msg + `'${notation}'`);\n        }\n        return result.has ? result.value : defaultValue;\n    }\n\n    /**\n     *  Sets the value of the corresponding property at the given notation. If\n     *  the property does not exist, it will be created and nested at the\n     *  calculated level. If it exists; its value will be overwritten by\n     *  default.\n     *  @chainable\n     *\n     *  @param {String} notation - The notation string to be processed.\n     *  @param {*} value - The value to be set for the notated property.\n     *  @param {String|Boolean} [mode=\"overwrite\"] - Write mode. By default,\n     *  this is set to `\"overwrite\"` which sets the value by overwriting the\n     *  target object property or array item at index. To insert an array item\n     *  (by shifting the index, instead of overwriting); set to `\"insert\"`. To\n     *  prevent overwriting the value if exists, explicitly set to `false`.\n     *\n     *  @returns {Notation} - The current `Notation` instance (self).\n     *\n     *  @throws {NotationError} - If strict notation is enabled, `overwrite`\n     *  option is set to `false` and attempted to overwrite an existing value.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", year: 1970 } };\n     *  Notation.create(obj)\n     *      .set(\"car.brand\", \"Ford\")\n     *      .set(\"car.model\", \"Mustang\")\n     *      .set(\"car.year\", 1965, false)\n     *      .set(\"car.color\", \"red\")\n     *      .set(\"boat\", \"none\");\n     *  console.log(obj);\n     *  // { notebook: \"Mac\", car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" }, boat: \"none\" };\n     */\n    set(notation, value, mode = 'overwrite') {\n        if (!notation.trim()) throw new NotationError(ERR.NOTATION + `'${notation}'`);\n        if (mode === true) mode = 'overwrite';\n        let level = this._source;\n        let currentIsLast, nCurrentNote, nNextNote, nextIsArrayNote, type;\n        const insertErrMsg = 'Cannot set value by inserting at index, on an object';\n\n        Notation.eachNote(notation, (levelNotation, note, index, list) => {\n            currentIsLast = index === list.length - 1;\n            nCurrentNote = nNextNote || utils.normalizeNote(note);\n            nNextNote = currentIsLast ? null : utils.normalizeNote(list[index + 1]);\n            type = utils.type(level);\n\n            if (type === 'array' && typeof nCurrentNote !== 'number') {\n                const parent = Notation.parent(levelNotation) || 'source';\n                throw new NotationError(`Cannot set string key '${note}' on array ${parent}`);\n            }\n\n            // check if the property is at this level\n            if (utils.hasOwn(level, nCurrentNote, type)) {\n                // check if we're at the last level\n                if (currentIsLast) {\n                    // if mode is \"overwrite\", assign the value.\n                    if (mode === 'overwrite') {\n                        level[nCurrentNote] = value;\n                    } else if (mode === 'insert') {\n                        if (type === 'array') {\n                            level.splice(nCurrentNote, 0, value);\n                        } else {\n                            throw new NotationError(insertErrMsg);\n                        }\n                    }\n                    // otherwise, will not overwrite\n                } else {\n                    // if not last level; just re-reference the current level.\n                    level = level[nCurrentNote];\n                }\n            } else {\n                if (currentIsLast && type !== 'array' && mode === 'insert') {\n                    throw new NotationError(insertErrMsg);\n                }\n\n                // if next normalized note is a number, it indicates that the\n                // current note is actually an array.\n                nextIsArrayNote = typeof nNextNote === 'number';\n\n                // we don't have this property at this level so; if this is the\n                // last level, we set the value if not, we set an empty\n                // collection for the next level\n                level[nCurrentNote] = (currentIsLast ? value : (nextIsArrayNote ? [] : {}));\n                level = level[nCurrentNote];\n            }\n        });\n        return this;\n    }\n\n    /**\n     *  Just like the `.set()` method but instead of a single notation\n     *  string, an object of notations and values can be passed.\n     *  Sets the value of each corresponding property at the given\n     *  notation. If a property does not exist, it will be created\n     *  and nested at the calculated level. If it exists; its value\n     *  will be overwritten by default.\n     *  @chainable\n     *\n     *  @param {Object} notationsObject - The notations object to be processed.\n     *  This can either be a regular object with non-dotted keys\n     *  (which will be merged to the first/root level of the source object);\n     *  or a flattened object with notated (dotted) keys.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite a property if\n     *  exists.\n     *\n     *  @returns {Notation} - The current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", year: 1970 } };\n     *  Notation.create(obj).merge({\n     *      \"car.brand\": \"Ford\",\n     *      \"car.model\": \"Mustang\",\n     *      \"car.year\": 1965,\n     *      \"car.color\": \"red\",\n     *      \"boat\": \"none\"\n     *  });\n     *  console.log(obj);\n     *  // { car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" }, boat: \"none\" };\n     */\n    merge(notationsObject, overwrite = true) {\n        if (utils.type(notationsObject) !== 'object') {\n            throw new NotationError(ERR.NOTA_OBJ + 'Expected an object.');\n        }\n        let value;\n        utils.each(Object.keys(notationsObject), notation => {\n            value = notationsObject[notation];\n            this.set(notation, value, overwrite);\n        });\n        return this;\n    }\n\n    /**\n     *  Removes the properties by the given list of notations from the source\n     *  object and returns a new object with the removed properties.\n     *  Opposite of `merge()` method.\n     *\n     *  @param {Array} notations - The notations array to be processed.\n     *\n     *  @returns {Object} - An object with the removed properties.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", year: 1970 }, notebook: \"Mac\" };\n     *  const separated = Notation.create(obj).separate([\"car.brand\", \"boat\" ]);\n     *  console.log(separated);\n     *  // { notebook: \"Mac\", car: { brand: \"Ford\" } };\n     *  console.log(obj);\n     *  // { car: { year: 1970 } };\n     */\n    separate(notations) {\n        if (utils.type(notations) !== 'array') {\n            throw new NotationError(ERR.NOTA_OBJ + 'Expected an array.');\n        }\n        const o = new Notation({});\n        utils.each(notations, notation => {\n            const result = this.inspectRemove(notation);\n            o.set(notation, result.value);\n        });\n        this._source = o._source;\n        return this;\n    }\n\n    /**\n     *  Deep clones the source object while filtering its properties by the\n     *  given <b>glob</b> notations. Includes all matched properties and removes\n     *  the rest.\n     *\n     *  The difference between regular notations and glob-notations is that;\n     *  with the latter, you can use wildcard stars (*) and negate the notation\n     *  by prepending a bang (!). A negated notation will be excluded.\n     *\n     *  Order of the globs does not matter; they will be logically sorted. Loose\n     *  globs will be processed first and verbose globs or normal notations will\n     *  be processed last. e.g. `[ \"car.model\", \"*\", \"!car.*\" ]` will be\n     *  normalized and sorted as `[ \"*\", \"!car\" ]`.\n     *\n     *  Passing no parameters or passing a glob of `\"!*\"` or `[\"!*\"]` will empty\n     *  the source object. See `Notation.Glob` class for more information.\n     *  @chainable\n     *\n     *  @param {Array|String} globList - Glob notation list to be processed.\n     *  @param {Object} [options] - Filter options.\n     *  @param {Boolean} [options.restrictive=false] - Whether negated items\n     *  strictly remove every match. Note that, regardless of this option, if\n     *  any item has an exact negated version; non-negated is always removed.\n     *\n     *  @returns {Notation} - The current `Notation` instance (self). To get the\n     *  filtered value, call `.value` property on the instance.\n     *\n     *  @example\n     *  const car = { brand: \"Ford\", model: { name: \"Mustang\", year: 1970 } };\n     *  const n = Notation.create(car);\n     *\n     *  console.log(n.filter([ \"*\", \"!model.year\" ]).value);  // { brand: \"Ford\", model: { name: \"Mustang\" } }\n     *  console.log(n.filter(\"model.name\").value);            // { model: { name: \"Mustang\" } }\n     *  console.log(car);                                     // { brand: \"Ford\", model: { name: \"Mustang\", year: 1970 } }\n     *  console.log(n.filter().value);                        // {} // —» equivalent to n.filter(\"\") or n.filter(\"!*\")\n     */\n    filter(globList, options = {}) {\n        const { re } = utils;\n\n        // ensure array, normalize and sort the globs in logical order. this\n        // also concats the array first (to prevent mutating the original\n        // array).\n        const globs = Glob.normalize(globList, options.restrictive);\n        const len = globs.length;\n        const empty = this._isArray ? [] : {};\n\n        // if globs is \"\" or [\"\"] or [\"!*\"] or [\"![*]\"] set source to empty and return.\n        if (len === 0 || (len === 1 && (!globs[0] || re.NEGATE_ALL.test(globs[0])))) {\n            this._source = empty;\n            return this;\n        }\n\n        const cloned = utils.cloneDeep(this.value);\n\n        const firstIsWildcard = re.WILDCARD.test(globs[0]);\n        // if globs only consist of \"*\" or \"[*]\"; set the \"clone\" as source and\n        // return.\n        if (len === 1 && firstIsWildcard) {\n            this._source = cloned;\n            return this;\n        }\n\n        let filtered;\n        // if the first item of sorted globs is \"*\" or \"[*]\" we set the source\n        // to the (full) \"copy\" and remove the wildcard from globs (not to\n        // re-process).\n        if (firstIsWildcard) {\n            filtered = new Notation(cloned);\n            globs.shift();\n        } else {\n            // otherwise we set an empty object or array as the source so that\n            // we can add notations/properties to it.\n            filtered = new Notation(empty);\n        }\n\n        // iterate through globs\n        utils.each(globs, globNotation => {\n            // console.log('globNotation', globNotation);\n            const g = new Glob(globNotation);\n            const { glob, absGlob, isNegated, levels } = g;\n            let normalized, emptyValue, eType;\n            // check whether the glob ends with `.*` or `[*]` then remove\n            // trailing glob note and decide for empty value (if negated). for\n            // non-negated, trailing wildcards are already removed by\n            // normalization.\n            if (absGlob.slice(-2) === '.*') {\n                normalized = absGlob.slice(0, -2);\n                /* istanbul ignore else */\n                if (isNegated) emptyValue = {};\n                eType = 'object';\n            } else if (absGlob.slice(-3) === '[*]') {\n                normalized = absGlob.slice(0, -3);\n                /* istanbul ignore else */\n                if (isNegated) emptyValue = [];\n                eType = 'array';\n            } else {\n                normalized = absGlob;\n            }\n\n            // we'll check glob vs value integrity if emptyValue is set; and throw if needed.\n            const errGlobIntegrity = `Integrity failed for glob '${glob}'. Cannot set empty ${eType} for '${normalized}' which has a type of `; // ...\n\n            // check if remaining normalized glob has no wildcard stars e.g.\n            // \"a.b\" or \"!a.b.c\" etc..\n            if (re.WILDCARDS.test(normalized) === false) {\n                if (isNegated) {\n                    // inspect and directly remove the notation if negated.\n                    // we need the inspection for the detailed error below.\n                    const insRemove = filtered.inspectRemove(normalized);\n                    // console.log('insRemove', insRemove);\n\n                    // if original glob had `.*` at the end, it means remove\n                    // contents (not itself). so we'll set an empty object.\n                    // meaning `some.prop` (prop) is removed completely but\n                    // `some.prop.*` (prop) results in `{}`. For array notation\n                    // (`[*]`), we'll set an empty array.\n                    if (emptyValue) {\n                        // e.g. for glob `![0].x.*` we expect to set `[0].x = {}`\n                        // but if `.x` is not an object (or array), we should fail.\n                        const vType = insRemove.type;\n                        const errMsg = errGlobIntegrity + `'${vType}'.`;\n                        // in non-strict mode, only exceptions are `null` and\n                        // `undefined`, for which we won't throw but we'll not\n                        // set an empty obj/arr either.\n\n                        const isValSet = utils.isset(insRemove.value);\n                        // on critical type mismatch we throw\n                        // or if original value is undefined or null in strict mode we throw\n                        if ((isValSet && vType !== eType) || (!isValSet && this.options.strict)) {\n                            throw new NotationError(errMsg);\n                        }\n                        // if parent is an array, we'll insert the value at\n                        // index bec. we've removed the item and indexes are\n                        // shifted. Otherwise, we'll simply overwrite the\n                        // object property value.\n                        const setMode = insRemove.parentIsArray ? 'insert' : 'overwrite';\n                        // console.log('setting', normalized, emptyValue, setMode);\n                        filtered.set(normalized, emptyValue, setMode);\n                    }\n                } else {\n                    // directly set the same notation from the original\n                    const insGet = this.inspectGet(normalized); // Notation.create(original).inspectGet ...\n                    /* istanbul ignore else */\n                    if (insGet.has) filtered.set(normalized, insGet.value, 'overwrite');\n                }\n                // move to the next\n                return true;\n            }\n\n            // if glob has wildcard(s), we'll iterate through keys of the source\n            // object and see if (full) notation of each key matches the current\n            // glob.\n\n            // important! we will iterate with eachRight to prevent shifted\n            // indexes when removing items from arrays.\n            const reverseIterateIfArray = true;\n\n            _each(this._source, (originalNotation, key, value) => {\n                const originalIsCovered = Glob.create(normalized).covers(originalNotation);\n                // console.log('» normalized:', normalized, 'covers', originalNotation, '»', originalIsCovered);\n                if (!originalIsCovered) return true; // break\n\n                if (this.options.strict && emptyValue) {\n                    // since original is covered and we have emptyValue set (due\n                    // to trailing wildcard), here we'll check value vs glob\n                    // integrity; (only if we're in strict mode).\n\n                    const vType = utils.type(value);\n                    // types and number of levels are the same?\n                    if (vType !== eType\n                            // we subtract 1 from number of levels bec. the last\n                            // note is removed since we have emptyValue set.\n                            && Notation.split(originalNotation).length === levels.length - 1) {\n                        throw new NotationError(errGlobIntegrity + `'${vType}'.`);\n                    }\n                }\n\n                // iterating each note of original notation. i.e.:\n                // note1.note2.note3 is iterated from left to right, as:\n                // 'note1', 'note1.note2', 'note1.note2.note3' — in order.\n                Notation.eachNote(originalNotation, levelNotation => {\n                    // console.log('  level »', glob, 'covers', levelNotation, '»', g.test(levelNotation));\n\n                    if (g.test(levelNotation)) {\n                        const levelLen = Notation.split(levelNotation).length;\n                        /* istanbul ignore else */\n                        if (isNegated && levels.length <= levelLen) {\n                            // console.log('  » removing', levelNotation, 'of', originalNotation);\n                            filtered.remove(levelNotation);\n                            // we break and return early if removed bec. e.g.\n                            // when 'note1.note2' (parent) of\n                            // 'note1.note2.note3' is also removed, we no more\n                            // have 'note3'.\n                            return false;\n                        }\n                        // console.log('  » setting', levelNotation, '=', value);\n                        filtered.set(levelNotation, value, 'overwrite');\n                    }\n                });\n            }, reverseIterateIfArray);\n        });\n        // finally set the filtered's value as the source of our instance and\n        // return.\n        this._source = filtered.value;\n        return this;\n    }\n\n    /**\n     *  Removes the property from the source object, at the given notation.\n     *  @alias Notation#delete\n     *  @chainable\n     *  @param {String} notation - The notation to be inspected.\n     *  @returns {Notation} - The current `Notation` instance (self).\n     *  @throws {NotationError} - If `strict` option is enabled and notation\n     *  does not exist.\n     *\n     *  @example\n     *  const obj = { notebook: \"Mac\", car: { model: \"Mustang\" } };\n     *  Notation.create(obj).remove(\"car.model\");\n     *  console.log(obj); // { notebook: \"Mac\", car: { } }\n     */\n    remove(notation) {\n        const result = this.inspectRemove(notation);\n        // if strict, check if implied index or prop exists\n        if (this.options.strict && !result.has) {\n            const msg = result.parentIsArray ? ERR.NO_INDEX : ERR.NO_PROP;\n            throw new NotationError(msg + `'${notation}'`);\n        }\n        return this;\n    }\n\n    /**\n     *  Alias of `Notation#remove`\n     *  @private\n     *  @param {String} notation -\n     *  @returns {Notation} -\n     */\n    delete(notation) {\n        this.remove(notation);\n        return this;\n    }\n\n    /**\n     *  Copies the notated property from the source collection and adds it to the\n     *  destination — only if the source object actually has that property.\n     *  This is different than a property with a value of `undefined`.\n     *  @chainable\n     *\n     *  @param {Object|Array} destination - The destination object that the notated\n     *  properties will be copied to.\n     *  @param {String} notation - The notation to get the corresponding property\n     *  from the source object.\n     *  @param {String} [newNotation=null] - The notation to set the source property\n     *  on the destination object. In other words, the copied property will be\n     *  renamed to this value before set on the destination object. If not set,\n     *  `notation` argument will be used.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\n     *  the destination object if it exists.\n     *\n     *  @returns {Notation} - The current `Notation` instance (self).\n     *\n     *  @throws {NotationError} - If `destination` is not a valid collection.\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const models = { dodge: \"Charger\" };\n     *  Notation.create(obj).copyTo(models, \"car.model\", \"ford\");\n     *  console.log(models);\n     *  // { dodge: \"Charger\", ford: \"Mustang\" }\n     *  // source object (obj) is not modified\n     */\n    copyTo(destination, notation, newNotation = null, overwrite = true) {\n        if (!utils.isCollection(destination)) throw new NotationError(ERR.DEST);\n        const result = this.inspectGet(notation);\n        if (result.has) {\n            const newN = utils.getNewNotation(newNotation, notation);\n            Notation.create(destination).set(newN, result.value, overwrite);\n        }\n        return this;\n    }\n\n    /**\n     *  Copies the notated property from the target collection and adds it to\n     *  (own) source object — only if the target object actually has that\n     *  property. This is different than a property with a value of `undefined`.\n     *  @chainable\n     *\n     *  @param {Object|Array} target - The target collection that the notated\n     *  properties will be copied from.\n     *  @param {String} notation - The notation to get the corresponding\n     *  property from the target object.\n     *  @param {String} [newNotation=null] - The notation to set the copied\n     *  property on our source collection. In other words, the copied property\n     *  will be renamed to this value before set. If not set, `notation`\n     *  argument will be used.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\n     *  our collection if it exists.\n     *\n     *  @returns {Notation} - The current `Notation` instance (self).\n     *\n     *  @throws {NotationError} - If `target` is not a valid collection.\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const models = { dodge: \"Charger\" };\n     *  Notation.create(obj).copyFrom(models, \"dodge\", \"car.model\", true);\n     *  console.log(obj);\n     *  // { car: { brand: \"Ford\", model: \"Charger\" } }\n     *  // models object is not modified\n     */\n    copyFrom(target, notation, newNotation = null, overwrite = true) {\n        if (!utils.isCollection(target)) throw new NotationError(ERR.DEST);\n        const result = Notation.create(target).inspectGet(notation);\n        if (result.has) {\n            const newN = utils.getNewNotation(newNotation, notation);\n            this.set(newN, result.value, overwrite);\n        }\n        return this;\n    }\n\n    /**\n     *  Removes the notated property from the source (own) collection and adds\n     *  it to the destination — only if the source collection actually has that\n     *  property. This is different than a property with a value of `undefined`.\n     *  @chainable\n     *\n     *  @param {Object|Array} destination - The destination collection that the\n     *  notated properties will be moved to.\n     *  @param {String} notation - The notation to get the corresponding\n     *  property from the source object.\n     *  @param {String} [newNotation=null] - The notation to set the source\n     *  property on the destination object. In other words, the moved property\n     *  will be renamed to this value before set on the destination object. If\n     *  not set, `notation` argument will be used.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\n     *  the destination object if it exists.\n     *\n     *  @returns {Notation} - The current `Notation` instance (self).\n     *\n     *  @throws {NotationError} - If `destination` is not a valid collection.\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const models = { dodge: \"Charger\" };\n     *  Notation.create(obj).moveTo(models, \"car.model\", \"ford\");\n     *  console.log(obj);\n     *  // { car: { brand: \"Ford\" } }\n     *  console.log(models);\n     *  // { dodge: \"Charger\", ford: \"Mustang\" }\n     */\n    moveTo(destination, notation, newNotation = null, overwrite = true) {\n        if (!utils.isCollection(destination)) throw new NotationError(ERR.DEST);\n        const result = this.inspectRemove(notation);\n        if (result.has) {\n            const newN = utils.getNewNotation(newNotation, notation);\n            Notation.create(destination).set(newN, result.value, overwrite);\n        }\n        return this;\n    }\n\n    /**\n     *  Removes the notated property from the target collection and adds it to (own)\n     *  source collection — only if the target object actually has that property.\n     *  This is different than a property with a value of `undefined`.\n     *  @chainable\n     *\n     *  @param {Object|Array} target - The target collection that the notated\n     *  properties will be moved from.\n     *  @param {String} notation - The notation to get the corresponding property\n     *  from the target object.\n     *  @param {String} [newNotation=null] - The notation to set the target\n     *  property on the source object. In other words, the moved property\n     *  will be renamed to this value before set on the source object.\n     *  If not set, `notation` argument will be used.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\n     *  the source object if it exists.\n     *\n     *  @returns {Notation} - The current `Notation` instance (self).\n     *\n     *  @throws {NotationError} - If `target` is not a valid collection.\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const models = { dodge: \"Charger\" };\n     *  Notation.create(obj).moveFrom(models, \"dodge\", \"car.model\", true);\n     *  console.log(obj);\n     *  // { car: { brand: \"Ford\", model: \"Charger\" } }\n     *  console.log(models);\n     *  // {}\n     */\n    moveFrom(target, notation, newNotation = null, overwrite = true) {\n        if (!utils.isCollection(target)) throw new NotationError(ERR.DEST);\n        const result = Notation.create(target).inspectRemove(notation);\n        if (result.has) {\n            const newN = utils.getNewNotation(newNotation, notation);\n            this.set(newN, result.value, overwrite);\n        }\n        return this;\n    }\n\n    /**\n     *  Renames the notated property of the source collection by the new notation.\n     *  @alias Notation#renote\n     *  @chainable\n     *\n     *  @param {String} notation - The notation to get the corresponding\n     *  property (value) from the source collection.\n     *  @param {String} newNotation - The new notation for the targeted\n     *  property value. If not set, the source collection will not be modified.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property at\n     *  the new notation, if it exists.\n     *\n     *  @returns {Notation} - The current `Notation` instance (self).\n     *\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  Notation.create(obj)\n     *      .rename(\"car.brand\", \"carBrand\")\n     *      .rename(\"car.model\", \"carModel\");\n     *  console.log(obj);\n     *  // { carBrand: \"Ford\", carModel: \"Mustang\" }\n     */\n    rename(notation, newNotation, overwrite) {\n        return this.moveTo(this._source, notation, newNotation, overwrite);\n    }\n\n    /**\n     *  Alias for `#rename`\n     *  @private\n     *  @param {String} notation -\n     *  @param {String} newNotation -\n     *  @param {Boolean} [overwrite=true] -\n     *  @returns {Notation} -\n     */\n    renote(notation, newNotation, overwrite) {\n        return this.rename(notation, newNotation, overwrite);\n    }\n\n    /**\n     *  Extracts the property at the given notation to a new object by copying\n     *  it from the source collection. This is equivalent to `.copyTo({},\n     *  notation, newNotation)`.\n     *  @alias Notation#copyToNew\n     *\n     *  @param {String} notation - The notation to get the corresponding\n     *  property (value) from the source object.\n     *  @param {String} newNotation - The new notation to be set on the new\n     *  object for the targeted property value. If not set, `notation` argument\n     *  will be used.\n     *\n     *  @returns {Object} - Returns a new object with the notated property.\n     *\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const extracted = Notation.create(obj).extract(\"car.brand\", \"carBrand\");\n     *  console.log(extracted);\n     *  // { carBrand: \"Ford\" }\n     *  // obj is not modified\n     */\n    extract(notation, newNotation) {\n        const o = {};\n        this.copyTo(o, notation, newNotation);\n        return o;\n    }\n\n    /**\n     *  Alias for `#extract`\n     *  @private\n     *  @param {String} notation -\n     *  @param {String} newNotation -\n     *  @returns {Object} -\n     */\n    copyToNew(notation, newNotation) {\n        return this.extract(notation, newNotation);\n    }\n\n    /**\n     *  Extrudes the property at the given notation to a new collection by\n     *  moving it from the source collection. This is equivalent to `.moveTo({},\n     *  notation, newNotation)`.\n     *  @alias Notation#moveToNew\n     *\n     *  @param {String} notation - The notation to get the corresponding\n     *  property (value) from the source object.\n     *  @param {String} newNotation - The new notation to be set on the new\n     *  object for the targeted property value. If not set, `notation` argument\n     *  will be used.\n     *\n     *  @returns {Object} - Returns a new object with the notated property.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const extruded = Notation.create(obj).extrude(\"car.brand\", \"carBrand\");\n     *  console.log(obj);\n     *  // { car: { model: \"Mustang\" } }\n     *  console.log(extruded);\n     *  // { carBrand: \"Ford\" }\n     */\n    extrude(notation, newNotation) {\n        const o = {};\n        this.moveTo(o, notation, newNotation);\n        return o;\n    }\n\n    /**\n     *  Alias for `#extrude`\n     *  @private\n     *  @param {String} notation -\n     *  @param {String} newNotation -\n     *  @returns {Object} -\n     */\n    moveToNew(notation, newNotation) {\n        return this.extrude(notation, newNotation);\n    }\n\n    // --------------------------------\n    // STATIC MEMBERS\n    // --------------------------------\n\n    /**\n     *  Basically constructs a new `Notation` instance.\n     *  @chainable\n     *  @param {Object|Array} [source={}] - The source collection to be notated.\n     *  @param {Object} [options] - Notation options.\n     *      @param {Boolean} [options.strict=false] - Whether to throw when a\n     *      notation path does not exist on the source. (Note that `.inspectGet()`\n     *      and `.inspectRemove()` methods are exceptions). It's recommended to\n     *      set this to `true` and prevent silent failures if you're working\n     *      with sensitive data. Regardless of `strict` option, it will always\n     *      throw on invalid notation syntax or other crucial failures.\n     *\n     *  @returns {Notation} - The created instance.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  const notation = Notation.create(obj); // equivalent to new Notation(obj)\n     *  notation.get('car.model')   // » \"Charger\"\n     *  notation.remove('car.model').set('car.color', 'red').value\n     *  // » { car: { brand: \"Dodge\", year: 1970, color: \"red\" } }\n     */\n    static create(source, options) {\n        if (arguments.length === 0) {\n            return new Notation({});\n        }\n        return new Notation(source, options);\n    }\n\n    /**\n     *  Checks whether the given notation string is valid. Note that the star\n     *  (`*`) (which is a valid character, even if irregular) is NOT treated as\n     *  wildcard here. This checks for regular dot-notation, not a glob-notation.\n     *  For glob notation validation, use `Notation.Glob.isValid()` method. Same\n     *  goes for the negation character/prefix (`!`).\n     *\n     *  @param {String} notation - The notation string to be checked.\n     *  @returns {Boolean} -\n     *\n     *  @example\n     *  Notation.isValid('prop1.prop2.prop3'); // true\n     *  Notation.isValid('x'); // true\n     *  Notation.isValid('x.arr[0].y'); // true\n     *  Notation.isValid('x[\"*\"]'); // true\n     *  Notation.isValid('x.*'); // false (this would be valid for Notation#filter() only or Notation.Glob class)\n     *  Notation.isValid('@1'); // false (should be \"['@1']\")\n     *  Notation.isValid(null); // false\n     */\n    static isValid(notation) {\n        return typeof notation === 'string' && reVALIDATOR.test(notation);\n    }\n\n    /**\n     *  Splits the given notation string into its notes (levels).\n     *  @param {String} notation  Notation string to be splitted.\n     *  @returns {Array} - A string array of notes (levels).\n     *  @throws {NotationError} - If given notation is invalid.\n     */\n    static split(notation) {\n        if (!Notation.isValid(notation)) {\n            throw new NotationError(ERR.NOTATION + `'${notation}'`);\n        }\n        return notation.match(reMATCHER);\n    }\n\n    /**\n     *  Joins the given notes into a notation string.\n     *  @param {String} notes  Notes (levels) to be joined.\n     *  @returns {String}  Joined notation string.\n     */\n    static join(notes) {\n        return utils.joinNotes(notes);\n    }\n\n    /**\n     *  Counts the number of notes/levels in the given notation.\n     *  @alias Notation.countLevels\n     *  @param {String} notation - The notation string to be processed.\n     *  @returns {Number} - Number of notes.\n     *  @throws {NotationError} - If given notation is invalid.\n     */\n    static countNotes(notation) {\n        return Notation.split(notation).length;\n    }\n\n    /**\n     *  Alias of `Notation.countNotes`.\n     *  @private\n     *  @param {String} notation -\n     *  @returns {Number} -\n     */\n    static countLevels(notation) {\n        return Notation.countNotes(notation);\n    }\n\n    /**\n     *  Gets the first (root) note of the notation string.\n     *  @param {String} notation - The notation string to be processed.\n     *  @returns {String} - First note.\n     *  @throws {NotationError} - If given notation is invalid.\n     *\n     *  @example\n     *  Notation.first('first.prop2.last'); // \"first\"\n     */\n    static first(notation) {\n        return Notation.split(notation)[0];\n    }\n\n    /**\n     *  Gets the last note of the notation string.\n     *  @param {String} notation - The notation string to be processed.\n     *  @returns {String} - Last note.\n     *  @throws {NotationError} - If given notation is invalid.\n     *\n     *  @example\n     *  Notation.last('first.prop2.last'); // \"last\"\n     */\n    static last(notation) {\n        const list = Notation.split(notation);\n        return list[list.length - 1];\n    }\n\n    /**\n     *  Gets the parent notation (up to but excluding the last note)\n     *  from the notation string.\n     *  @param {String} notation - The notation string to be processed.\n     *  @returns {String} - Parent note if any. Otherwise, `null`.\n     *  @throws {NotationError} - If given notation is invalid.\n     *\n     *  @example\n     *  Notation.parent('first.prop2.last'); // \"first.prop2\"\n     *  Notation.parent('single'); // null\n     */\n    static parent(notation) {\n        const last = Notation.last(notation);\n        return notation.slice(0, -last.length).replace(/\\.$/, '') || null;\n    }\n\n    /**\n     *  Iterates through each note/level of the given notation string.\n     *  @alias Notation.eachLevel\n     *\n     *  @param {String} notation - The notation string to be iterated through.\n     *  @param {Function} callback - The callback function to be invoked on\n     *  each iteration. To break out of the loop, return `false` from within the\n     *  callback.\n     *  Callback signature: `callback(levelNotation, note, index, list) { ... }`\n     *\n     *  @returns {void}\n     *  @throws {NotationError} - If given notation is invalid.\n     *\n     *  @example\n     *  const notation = 'first.prop2.last';\n     *  Notation.eachNote(notation, function (levelNotation, note, index, list) {\n     *      console.log(index, note, levelNotation);\n     *  });\n     *  // 0  \"first\"             \"first\"\n     *  // 1  \"first.prop2\"       \"prop2\"\n     *  // 2  \"first.prop2.last\"  \"last\"\n     */\n    static eachNote(notation, callback) {\n        const notes = Notation.split(notation);\n        const levelNotes = [];\n        utils.each(notes, (note, index) => {\n            levelNotes.push(note);\n            if (callback(Notation.join(levelNotes), note, index, notes) === false) return false;\n        }, Notation);\n    }\n\n    /**\n     *  Alias of `Notation.eachNote`.\n     *  @private\n     *  @param {String} notation -\n     *  @param {Function} callback -\n     *  @returns {void}\n     */\n    static eachLevel(notation, callback) {\n        Notation.eachNote(notation, callback);\n    }\n\n}\n\n/**\n *  Error class specific to `Notation`.\n *  @private\n *\n *  @class\n *  @see `{@link #Notation.Error}`\n */\nNotation.Error = NotationError;\n\n/**\n *  Utility for validating, comparing and sorting dot-notation globs.\n *  This is internally used by `Notation` class.\n *  @private\n *\n *  @class\n *  @see `{@link #Notation.Glob}`\n */\nNotation.Glob = Glob;\n\n/**\n *  Undocumented\n *  @private\n */\nNotation.utils = utils;\n\n// --------------------------------\n// HELPERS\n// --------------------------------\n\n/**\n *  Deep iterates through each note (level) of each item in the given\n *  collection.\n *  @private\n *  @param {Object|Array} collection  A data object or an array, as the source.\n *  @param {Function} callback  A function to be executed on each iteration,\n *  with the following arguments: `(levelNotation, note, value, collection)`\n *  @param {Boolean} [reverseIfArray=false]  Set to `true` to iterate with\n *  `eachRight` to prevent shifted indexes when removing items from arrays.\n *  @param {Boolean} [byLevel=false]  Indicates whether to iterate notations by\n *  each level or by the end value.  For example, if we have a collection of\n *  `{a: { b: true } }`, and `byLevel` is set; the callback will be invoked on\n *  the following notations: `a`, `a.b`. Otherwise, it will be invoked only on\n *  `a.b`.\n *  @param {String} [parentNotation]  Storage for parent (previous) notation.\n *  @param {Collection} [topSource]  Storage for initial/main collection.\n *  @returns {void}\n */\nfunction _each(collection, callback, reverseIfArray = false, byLevel = false, parentNotation = null, topSource = null) { // eslint-disable-line max-params\n    const source = topSource || collection;\n    // if (!utils.isCollection(collection)) throw ... // no need\n    utils.eachItem(collection, (value, keyOrIndex) => {\n        const note = typeof keyOrIndex === 'number'\n            ? `[${keyOrIndex}]`\n            : keyOrIndex;\n        const currentNotation = Notation.join([parentNotation, note]);\n        const isCollection = utils.isCollection(value);\n        // if it's not a collection we'll execute the callback. if it's a\n        // collection but byLevel is set, we'll also execute the callback.\n        if (!isCollection || byLevel) {\n            if (callback(currentNotation, note, value, source) === false) return false;\n        }\n        // deep iterating if collection\n        if (isCollection) _each(value, callback, reverseIfArray, byLevel, currentNotation, source);\n    }, null, reverseIfArray);\n}\n\n// --------------------------------\n// EXPORT\n// --------------------------------\n\nexport { Notation };\n","/* istanbul ignore file */\nexport * from './core/notation';\n","\nimport { NotationError } from './core/notation.error';\n\nconst objProto = Object.prototype;\nconst symValueOf = typeof Symbol === 'function'\n    ? Symbol.prototype.valueOf\n    /* istanbul ignore next */\n    : null;\n\n// never use 'g' (global) flag in regexps below\nconst VAR = /^[a-z$_][a-z$_\\d]*$/i;\nconst ARRAY_NOTE = /^\\[(\\d+)\\]$/;\nconst ARRAY_GLOB_NOTE = /^\\[(\\d+|\\*)\\]$/;\nconst OBJECT_BRACKETS = /^\\[(?:'(.*)'|\"(.*)\"|`(.*)`)\\]$/;\nconst WILDCARD = /^(\\[\\*\\]|\\*)$/;\n// matches `*` and `[*]` if outside of quotes.\nconst WILDCARDS = /(\\*|\\[\\*\\])(?=(?:[^\"]|\"[^\"]*\")*$)(?=(?:[^']|'[^']*')*$)/;\n// matches trailing wildcards at the end of a non-negated glob.\n// e.g. `x.y.*[*].*` » $1 = `x.y`, $2 = `.*[*].*`\nconst NON_NEG_WILDCARD_TRAIL = /^(?!!)(.+?)(\\.\\*|\\[\\*\\])+$/;\nconst NEGATE_ALL = /^!(\\*|\\[\\*\\])$/;\n// ending with '.*' or '[*]'\n\nconst _reFlags = /\\w*$/;\n\nconst utils = {\n\n    re: {\n        VAR,\n        ARRAY_NOTE,\n        ARRAY_GLOB_NOTE,\n        OBJECT_BRACKETS,\n        WILDCARD,\n        WILDCARDS,\n        NON_NEG_WILDCARD_TRAIL,\n        NEGATE_ALL\n    },\n\n    type(o) {\n        return objProto.toString.call(o).match(/\\s(\\w+)/i)[1].toLowerCase();\n    },\n\n    isCollection(o) {\n        const t = utils.type(o);\n        return t === 'object' || t === 'array';\n    },\n\n    isset(o) {\n        return o !== undefined && o !== null;\n    },\n\n    ensureArray(o) {\n        if (utils.type(o) === 'array') return o;\n        return o === null || o === undefined ? [] : [o];\n    },\n\n    // simply returning true will get rid of the \"holes\" in the array.\n    // e.g. [0, , 1, , undefined, , , 2, , , null].filter(() => true);\n    // ——» [0, 1, undefined, 2, null]\n\n    // cleanSparseArray(a) {\n    //     return a.filter(() => true);\n    // },\n\n    // added _collectionType for optimization (in loops)\n    hasOwn(collection, keyOrIndex, _collectionType) {\n        if (!collection) return false;\n        const isArr = (_collectionType || utils.type(collection)) === 'array';\n        if (!isArr && typeof keyOrIndex === 'string') {\n            return keyOrIndex && objProto.hasOwnProperty.call(collection, keyOrIndex);\n        }\n        if (typeof keyOrIndex === 'number') {\n            return keyOrIndex >= 0 && keyOrIndex < collection.length;\n        }\n        return false;\n    },\n\n    cloneDeep(collection) {\n        const t = utils.type(collection);\n        switch (t) {\n            case 'date':\n                return new Date(collection.valueOf());\n            case 'regexp': {\n                const flags = _reFlags.exec(collection).toString();\n                const copy = new collection.constructor(collection.source, flags);\n                copy.lastIndex = collection.lastIndex;\n                return copy;\n            }\n            case 'symbol':\n                return symValueOf\n                    ? Object(symValueOf.call(collection))\n                    /* istanbul ignore next */\n                    : collection;\n            case 'array':\n                return collection.map(utils.cloneDeep);\n            case 'object': {\n                const copy = {};\n                // only enumerable string keys\n                Object.keys(collection).forEach(k => {\n                    copy[k] = utils.cloneDeep(collection[k]);\n                });\n                return copy;\n            }\n            // primitives copied over by value\n            // case 'string':\n            // case 'number':\n            // case 'boolean':\n            // case 'null':\n            // case 'undefined':\n            default: // others will be referenced\n                return collection;\n        }\n    },\n\n    // iterates over elements of an array, executing the callback for each\n    // element.\n    each(array, callback, thisArg) {\n        const len = array.length;\n        let index = -1;\n        while (++index < len) {\n            if (callback.apply(thisArg, [array[index], index, array]) === false) break;\n        }\n    },\n\n    eachRight(array, callback, thisArg) {\n        let index = array.length;\n        while (index--) {\n            if (callback.apply(thisArg, [array[index], index, array]) === false) break;\n        }\n    },\n\n    eachProp(object, callback, thisArg) {\n        const keys = Object.keys(object);\n        let index = -1;\n        while (++index < keys.length) {\n            const key = keys[index];\n            if (callback.apply(thisArg, [object[key], key, object]) === false) break;\n        }\n    },\n\n    eachItem(collection, callback, thisArg, reverseIfArray = false) {\n        if (utils.type(collection) === 'array') {\n            // important! we should iterate with eachRight to prevent shifted\n            // indexes when removing items from arrays.\n            return reverseIfArray\n                ? utils.eachRight(collection, callback, thisArg)\n                : utils.each(collection, callback, thisArg);\n        }\n        return utils.eachProp(collection, callback, thisArg);\n    },\n\n    pregQuote(str) {\n        const re = /[.\\\\+*?[^\\]$(){}=!<>|:-]/g;\n        return String(str).replace(re, '\\\\$&');\n    },\n\n    stringOrArrayOf(o, value) {\n        return typeof value === 'string'\n            && (o === value\n                || (utils.type(o) === 'array' && o.length === 1 && o[0] === value)\n            );\n    },\n\n    hasSingleItemOf(arr, itemValue) {\n        return arr.length === 1\n            && (arguments.length === 2 ? arr[0] === itemValue : true);\n    },\n\n    // remove trailing/redundant wildcards if not negated\n    removeTrailingWildcards(glob) {\n        // return glob.replace(/(.+?)(\\.\\*|\\[\\*\\])*$/, '$1');\n        return glob.replace(NON_NEG_WILDCARD_TRAIL, '$1');\n    },\n\n    normalizeNote(note) {\n        if (VAR.test(note)) return note;\n        // check array index notation e.g. `[1]`\n        let m = note.match(ARRAY_NOTE);\n        if (m) return parseInt(m[1], 10);\n        // check object bracket notation e.g. `[\"a-b\"]`\n        m = note.match(OBJECT_BRACKETS);\n        if (m) return (m[1] || m[2] || m[3]);\n        throw new NotationError(`Invalid note: '${note}'`);\n    },\n\n    joinNotes(notes) {\n        const lastIndex = notes.length - 1;\n        return notes.map((current, i) => {\n            if (!current) return '';\n            const next = lastIndex >= i + 1 ? notes[i + 1] : null;\n            const dot = next\n                ? next[0] === '[' ? '' : '.'\n                : '';\n            return current + dot;\n        }).join('');\n    },\n\n    getNewNotation(newNotation, notation) {\n        const errMsg = `Invalid new notation: '${newNotation}'`;\n        // note validations (for newNotation and notation) are already made by\n        // other methods in the flow.\n        let newN;\n        if (typeof newNotation === 'string') {\n            newN = newNotation.trim();\n            if (!newN) throw new NotationError(errMsg);\n            return newN;\n        }\n        if (notation && !utils.isset(newNotation)) return notation;\n        throw new NotationError(errMsg);\n    }\n\n};\n\nexport { utils };\n"],"sourceRoot":""}